#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Blutility

#include "Basic.hpp"

#include "Blutility_classes.hpp"
#include "Blutility_parameters.hpp"


namespace SDK
{

// Function Blutility.EditorUtilityObject.Run
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEditorUtilityObject::Run()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityObject", "Run");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.ActorActionUtility.GetSupportedClass
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UActorActionUtility::GetSupportedClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorActionUtility", "GetSupportedClass");

	Params::ActorActionUtility_GetSupportedClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Blutility.ActorActionUtility.GetSupportedClasses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<TSoftClassPtr<class UClass>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftClassPtr<class UClass>> UActorActionUtility::GetSupportedClasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorActionUtility", "GetSupportedClasses");

	Params::ActorActionUtility_GetSupportedClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AssetActionUtility.GetSupportedClass
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UAssetActionUtility::GetSupportedClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssetActionUtility", "GetSupportedClass");

	Params::AssetActionUtility_GetSupportedClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Blutility.AssetActionUtility.GetSupportedClasses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<TSoftClassPtr<class UClass>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftClassPtr<class UClass>> UAssetActionUtility::GetSupportedClasses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssetActionUtility", "GetSupportedClasses");

	Params::AssetActionUtility_GetSupportedClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AssetActionUtility.IsActionForBlueprints
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAssetActionUtility::IsActionForBlueprints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AssetActionUtility", "IsActionForBlueprints");

	Params::AssetActionUtility_IsActionForBlueprints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncCaptureScene.CaptureSceneAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 ViewCamera                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ASceneCapture2D>      SceneCaptureClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncCaptureScene*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncCaptureScene* UAsyncCaptureScene::CaptureSceneAsync(class UCameraComponent* ViewCamera, TSubclassOf<class ASceneCapture2D> SceneCaptureClass, int32 ResX, int32 ResY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncCaptureScene", "CaptureSceneAsync");

	Params::AsyncCaptureScene_CaptureSceneAsync Parms{};

	Parms.ViewCamera = ViewCamera;
	Parms.SceneCaptureClass = SceneCaptureClass;
	Parms.ResX = ResX;
	Parms.ResY = ResY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncCaptureScene.CaptureSceneWithWarmupAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 ViewCamera                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ASceneCapture2D>      SceneCaptureClass                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WarmUpFrames                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncCaptureScene*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncCaptureScene* UAsyncCaptureScene::CaptureSceneWithWarmupAsync(class UCameraComponent* ViewCamera, TSubclassOf<class ASceneCapture2D> SceneCaptureClass, int32 ResX, int32 ResY, int32 WarmUpFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncCaptureScene", "CaptureSceneWithWarmupAsync");

	Params::AsyncCaptureScene_CaptureSceneWithWarmupAsync Parms{};

	Parms.ViewCamera = ViewCamera;
	Parms.SceneCaptureClass = SceneCaptureClass;
	Parms.ResX = ResX;
	Parms.ResY = ResY;
	Parms.WarmUpFrames = WarmUpFrames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncImageExport.ExportImageAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         Texture                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutputFile                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quality_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncImageExport*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncImageExport* UAsyncImageExport::ExportImageAsync(class UTexture* Texture, const class FString& OutputFile, int32 Quality_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncImageExport", "ExportImageAsync");

	Params::AsyncImageExport_ExportImageAsync Parms{};

	Parms.Texture = Texture;
	Parms.OutputFile = std::move(OutputFile);
	Parms.Quality_0 = Quality_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncRegisterAndExecuteTask.RegisterAndExecuteTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEditorUtilityTask*               Task                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityTask*               OptionalParentTask                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncRegisterAndExecuteTask*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncRegisterAndExecuteTask* UAsyncRegisterAndExecuteTask::RegisterAndExecuteTask(class UEditorUtilityTask* Task, class UEditorUtilityTask* OptionalParentTask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncRegisterAndExecuteTask", "RegisterAndExecuteTask");

	Params::AsyncRegisterAndExecuteTask_RegisterAndExecuteTask Parms{};

	Parms.Task = Task;
	Parms.OptionalParentTask = OptionalParentTask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityActor.Run
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AEditorUtilityActor::Run()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityActor", "Run");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.EditorUtilityActor.SetReceivesEditorInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorUtilityActor::SetReceivesEditorInput(bool bInValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityActor", "SetReceivesEditorInput");

	Params::EditorUtilityActor_SetReceivesEditorInput Parms{};

	Parms.bInValue = bInValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityActor.GetInputComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInputComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInputComponent* AEditorUtilityActor::GetInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityActor", "GetInputComponent");

	Params::EditorUtilityActor_GetInputComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityActor.GetReceivesEditorInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEditorUtilityActor::GetReceivesEditorInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityActor", "GetReceivesEditorInput");

	Params::EditorUtilityActor_GetReceivesEditorInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncEditorDelay.AsyncEditorDelay
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFrames                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncEditorDelay*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncEditorDelay* UAsyncEditorDelay::AsyncEditorDelay(float Seconds, int32 MinimumFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncEditorDelay", "AsyncEditorDelay");

	Params::AsyncEditorDelay_AsyncEditorDelay Parms{};

	Parms.Seconds = Seconds;
	Parms.MinimumFrames = MinimumFrames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncEditorWaitForGameWorld.AsyncWaitForGameWorld
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Server                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncEditorWaitForGameWorld*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncEditorWaitForGameWorld* UAsyncEditorWaitForGameWorld::AsyncWaitForGameWorld(int32 Index_0, bool Server)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncEditorWaitForGameWorld", "AsyncWaitForGameWorld");

	Params::AsyncEditorWaitForGameWorld_AsyncWaitForGameWorld Parms{};

	Parms.Index_0 = Index_0;
	Parms.Server = Server;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.AsyncEditorOpenMapAndFocusActor.AsyncEditorOpenMapAndFocusActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, EditorOnly)
// Parameters:
// struct FSoftObjectPath                  Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FocusActorName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncEditorOpenMapAndFocusActor* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncEditorOpenMapAndFocusActor* UAsyncEditorOpenMapAndFocusActor::AsyncEditorOpenMapAndFocusActor(const struct FSoftObjectPath& Map, const class FString& FocusActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncEditorOpenMapAndFocusActor", "AsyncEditorOpenMapAndFocusActor");

	Params::AsyncEditorOpenMapAndFocusActor_AsyncEditorOpenMapAndFocusActor Parms{};

	Parms.Map = std::move(Map);
	Parms.FocusActorName = std::move(FocusActorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.ConvertToEditorUtilityWidget
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// class UWidgetBlueprint*                 WidgetBP                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilityLibrary::ConvertToEditorUtilityWidget(class UWidgetBlueprint* WidgetBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "ConvertToEditorUtilityWidget");

	Params::EditorUtilityLibrary_ConvertToEditorUtilityWidget Parms{};

	Parms.WidgetBP = WidgetBP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityLibrary.GetCurrentContentBrowserItemPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure, EditorOnly)
// Parameters:
// struct FContentBrowserItemPath          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FContentBrowserItemPath UEditorUtilityLibrary::GetCurrentContentBrowserItemPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetCurrentContentBrowserItemPath");

	Params::EditorUtilityLibrary_GetCurrentContentBrowserItemPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetCurrentContentBrowserPath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure, EditorOnly)
// Parameters:
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilityLibrary::GetCurrentContentBrowserPath(class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetCurrentContentBrowserPath");

	Params::EditorUtilityLibrary_GetCurrentContentBrowserPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedAssetData
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// TArray<struct FAssetData>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAssetData> UEditorUtilityLibrary::GetSelectedAssetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedAssetData");

	Params::EditorUtilityLibrary_GetSelectedAssetData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedAssets
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UEditorUtilityLibrary::GetSelectedAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedAssets");

	Params::EditorUtilityLibrary_GetSelectedAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedAssetsOfClass
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// class UClass*                           AssetClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UEditorUtilityLibrary::GetSelectedAssetsOfClass(class UClass* AssetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedAssetsOfClass");

	Params::EditorUtilityLibrary_GetSelectedAssetsOfClass Parms{};

	Parms.AssetClass = AssetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedBlueprintClasses
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// TArray<class UClass*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UClass*> UEditorUtilityLibrary::GetSelectedBlueprintClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedBlueprintClasses");

	Params::EditorUtilityLibrary_GetSelectedBlueprintClasses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedFolderPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure, EditorOnly)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UEditorUtilityLibrary::GetSelectedFolderPaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedFolderPaths");

	Params::EditorUtilityLibrary_GetSelectedFolderPaths Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectedPathViewFolderPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure, EditorOnly)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UEditorUtilityLibrary::GetSelectedPathViewFolderPaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectedPathViewFolderPaths");

	Params::EditorUtilityLibrary_GetSelectedPathViewFolderPaths Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.GetSelectionBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, EditorOnly)
// Parameters:
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilityLibrary::GetSelectionBounds(struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectionBounds");

	Params::EditorUtilityLibrary_GetSelectionBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

	if (SphereRadius != nullptr)
		*SphereRadius = Parms.SphereRadius;
}


// Function Blutility.EditorUtilityLibrary.GetSelectionSet
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UEditorUtilityLibrary::GetSelectionSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "GetSelectionSet");

	Params::EditorUtilityLibrary_GetSelectionSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityLibrary.RenameAsset
// (Final, Native, Static, Public, BlueprintCallable, EditorOnly)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilityLibrary::RenameAsset(class UObject* Asset, const class FString& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "RenameAsset");

	Params::EditorUtilityLibrary_RenameAsset Parms{};

	Parms.Asset = Asset;
	Parms.NewName = std::move(NewName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityLibrary.SyncBrowserToFolders
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, EditorOnly)
// Parameters:
// TArray<class FString>                   FolderList                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEditorUtilityLibrary::SyncBrowserToFolders(const TArray<class FString>& FolderList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EditorUtilityLibrary", "SyncBrowserToFolders");

	Params::EditorUtilityLibrary_SyncBrowserToFolders Parms{};

	Parms.FolderList = std::move(FolderList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityLibrary.GetActorReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure, EditorOnly)
// Parameters:
// class FString                           PathToActor                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEditorUtilityLibrary::GetActorReference(const class FString& PathToActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityLibrary", "GetActorReference");

	Params::EditorUtilityLibrary_GetActorReference Parms{};

	Parms.PathToActor = std::move(PathToActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.CloseTabByID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewTabID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::CloseTabByID(class FName NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "CloseTabByID");

	Params::EditorUtilitySubsystem_CloseTabByID Parms{};

	Parms.NewTabID = NewTabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.DoesTabExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewTabID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::DoesTabExist(class FName NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "DoesTabExist");

	Params::EditorUtilitySubsystem_DoesTabExist Parms{};

	Parms.NewTabID = NewTabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.FindUtilityWidgetFromBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEditorUtilityWidgetBlueprint*    InBlueprint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::FindUtilityWidgetFromBlueprint(class UEditorUtilityWidgetBlueprint* InBlueprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "FindUtilityWidgetFromBlueprint");

	Params::EditorUtilitySubsystem_FindUtilityWidgetFromBlueprint Parms{};

	Parms.InBlueprint = InBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.RegisterAndExecuteTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEditorUtilityTask*               NewTask                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityTask*               OptionalParentTask                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilitySubsystem::RegisterAndExecuteTask(class UEditorUtilityTask* NewTask, class UEditorUtilityTask* OptionalParentTask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "RegisterAndExecuteTask");

	Params::EditorUtilitySubsystem_RegisterAndExecuteTask Parms{};

	Parms.NewTask = NewTask;
	Parms.OptionalParentTask = OptionalParentTask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilitySubsystem.RegisterTabAndGetID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UEditorUtilityWidgetBlueprint*    InBlueprint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewTabID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilitySubsystem::RegisterTabAndGetID(class UEditorUtilityWidgetBlueprint* InBlueprint, class FName* NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "RegisterTabAndGetID");

	Params::EditorUtilitySubsystem_RegisterTabAndGetID Parms{};

	Parms.InBlueprint = InBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTabID != nullptr)
		*NewTabID = Parms.NewTabID;
}


// Function Blutility.EditorUtilitySubsystem.RegisterTabAndGetIDGeneratedClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           InGeneratedWidgetBlueprint                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewTabID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilitySubsystem::RegisterTabAndGetIDGeneratedClass(class UClass* InGeneratedWidgetBlueprint, class FName* NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "RegisterTabAndGetIDGeneratedClass");

	Params::EditorUtilitySubsystem_RegisterTabAndGetIDGeneratedClass Parms{};

	Parms.InGeneratedWidgetBlueprint = InGeneratedWidgetBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTabID != nullptr)
		*NewTabID = Parms.NewTabID;
}


// Function Blutility.EditorUtilitySubsystem.ReleaseInstanceOfAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditorUtilitySubsystem::ReleaseInstanceOfAsset(class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "ReleaseInstanceOfAsset");

	Params::EditorUtilitySubsystem_ReleaseInstanceOfAsset Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEditorUtilityWidgetBlueprint*    InBlueprint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTab(class UEditorUtilityWidgetBlueprint* InBlueprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTab");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTab Parms{};

	Parms.InBlueprint = InBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTabAndGetID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UEditorUtilityWidgetBlueprint*    InBlueprint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewTabID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTabAndGetID(class UEditorUtilityWidgetBlueprint* InBlueprint, class FName* NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTabAndGetID");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTabAndGetID Parms{};

	Parms.InBlueprint = InBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTabID != nullptr)
		*NewTabID = Parms.NewTabID;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTabAndGetIDGeneratedClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           InGeneratedWidgetBlueprint                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewTabID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTabAndGetIDGeneratedClass(class UClass* InGeneratedWidgetBlueprint, class FName* NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTabAndGetIDGeneratedClass");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTabAndGetIDGeneratedClass Parms{};

	Parms.InGeneratedWidgetBlueprint = InGeneratedWidgetBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTabID != nullptr)
		*NewTabID = Parms.NewTabID;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTabGeneratedClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           InGeneratedWidgetBlueprint                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTabGeneratedClass(class UClass* InGeneratedWidgetBlueprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTabGeneratedClass");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTabGeneratedClass Parms{};

	Parms.InGeneratedWidgetBlueprint = InGeneratedWidgetBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTabWithId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEditorUtilityWidgetBlueprint*    InBlueprint                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTabID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTabWithId(class UEditorUtilityWidgetBlueprint* InBlueprint, class FName InTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTabWithId");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTabWithId Parms{};

	Parms.InBlueprint = InBlueprint;
	Parms.InTabID = InTabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnAndRegisterTabWithIdGeneratedClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           InGeneratedWidgetBlueprint                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTabID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEditorUtilityWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorUtilityWidget* UEditorUtilitySubsystem::SpawnAndRegisterTabWithIdGeneratedClass(class UClass* InGeneratedWidgetBlueprint, class FName InTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnAndRegisterTabWithIdGeneratedClass");

	Params::EditorUtilitySubsystem_SpawnAndRegisterTabWithIdGeneratedClass Parms{};

	Parms.InGeneratedWidgetBlueprint = InGeneratedWidgetBlueprint;
	Parms.InTabID = InTabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.SpawnRegisteredTabByID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewTabID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::SpawnRegisteredTabByID(class FName NewTabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "SpawnRegisteredTabByID");

	Params::EditorUtilitySubsystem_SpawnRegisteredTabByID Parms{};

	Parms.NewTabID = NewTabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.TryRun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::TryRun(class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "TryRun");

	Params::EditorUtilitySubsystem_TryRun Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.TryRunClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ObjectClass                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::TryRunClass(class UClass* ObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "TryRunClass");

	Params::EditorUtilitySubsystem_TryRunClass Parms{};

	Parms.ObjectClass = ObjectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.UnregisterTabByID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TabID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::UnregisterTabByID(class FName TabID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "UnregisterTabByID");

	Params::EditorUtilitySubsystem_UnregisterTabByID Parms{};

	Parms.TabID = TabID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilitySubsystem.CanRun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilitySubsystem::CanRun(class UObject* Asset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilitySubsystem", "CanRun");

	Params::EditorUtilitySubsystem_CanRun Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityTask.FinishExecutingTask
// (Final, Native, Public, BlueprintCallable)

void UEditorUtilityTask::FinishExecutingTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "FinishExecutingTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityTask.ReceiveBeginExecution
// (Event, Protected, BlueprintEvent)

void UEditorUtilityTask::ReceiveBeginExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "ReceiveBeginExecution");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.EditorUtilityTask.ReceiveCancelRequested
// (Event, Protected, BlueprintEvent)

void UEditorUtilityTask::ReceiveCancelRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "ReceiveCancelRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.EditorUtilityTask.Run
// (Final, Native, Public)

void UEditorUtilityTask::Run()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "Run");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityTask.SetTaskNotificationText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEditorUtilityTask::SetTaskNotificationText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "SetTaskNotificationText");

	Params::EditorUtilityTask_SetTaskNotificationText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.EditorUtilityTask.GetTaskTitleOverride
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEditorUtilityTask::GetTaskTitleOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "GetTaskTitleOverride");

	Params::EditorUtilityTask_GetTaskTitleOverride Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityTask.WasCancelRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditorUtilityTask::WasCancelRequested() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityTask", "WasCancelRequested");

	Params::EditorUtilityTask_WasCancelRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.EditorUtilityWidget.Run
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEditorUtilityWidget::Run()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorUtilityWidget", "Run");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.GlobalEditorUtilityBase.ClearActorSelectionSet
// (Final, Native, Public, BlueprintCallable)

void UGlobalEditorUtilityBase::ClearActorSelectionSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "ClearActorSelectionSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.GlobalEditorUtilityBase.ForEachSelectedActor
// (Final, Native, Public, BlueprintCallable)

void UGlobalEditorUtilityBase::ForEachSelectedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "ForEachSelectedActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.GlobalEditorUtilityBase.ForEachSelectedAsset
// (Final, Native, Public, BlueprintCallable)

void UGlobalEditorUtilityBase::ForEachSelectedAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "ForEachSelectedAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.GlobalEditorUtilityBase.GetActorReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PathToActor                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGlobalEditorUtilityBase::GetActorReference(const class FString& PathToActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "GetActorReference");

	Params::GlobalEditorUtilityBase_GetActorReference Parms{};

	Parms.PathToActor = std::move(PathToActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.GlobalEditorUtilityBase.GetEditorUserSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEditorPerProjectUserSettings*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEditorPerProjectUserSettings* UGlobalEditorUtilityBase::GetEditorUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "GetEditorUserSettings");

	Params::GlobalEditorUtilityBase_GetEditorUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.GlobalEditorUtilityBase.GetSelectedAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UGlobalEditorUtilityBase::GetSelectedAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "GetSelectedAssets");

	Params::GlobalEditorUtilityBase_GetSelectedAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.GlobalEditorUtilityBase.GetSelectionBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEditorUtilityBase::GetSelectionBounds(struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "GetSelectionBounds");

	Params::GlobalEditorUtilityBase_GetSelectionBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

	if (SphereRadius != nullptr)
		*SphereRadius = Parms.SphereRadius;
}


// Function Blutility.GlobalEditorUtilityBase.GetSelectionSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UGlobalEditorUtilityBase::GetSelectionSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "GetSelectionSet");

	Params::GlobalEditorUtilityBase_GetSelectionSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.GlobalEditorUtilityBase.OnDefaultActionClicked
// (Event, Public, BlueprintEvent)

void UGlobalEditorUtilityBase::OnDefaultActionClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "OnDefaultActionClicked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Blutility.GlobalEditorUtilityBase.RenameAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEditorUtilityBase::RenameAsset(class UObject* Asset, const class FString& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "RenameAsset");

	Params::GlobalEditorUtilityBase_RenameAsset Parms{};

	Parms.Asset = Asset;
	Parms.NewName = std::move(NewName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.GlobalEditorUtilityBase.SelectNothing
// (Final, Native, Public, BlueprintCallable)

void UGlobalEditorUtilityBase::SelectNothing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "SelectNothing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.GlobalEditorUtilityBase.SetActorSelectionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBeSelected                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEditorUtilityBase::SetActorSelectionState(class AActor* Actor, bool bShouldBeSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEditorUtilityBase", "SetActorSelectionState");

	Params::GlobalEditorUtilityBase_SetActorSelectionState Parms{};

	Parms.Actor = Actor;
	Parms.bShouldBeSelected = bShouldBeSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.PlacedEditorUtilityBase.ClearActorSelectionSet
// (Final, Native, Public, BlueprintCallable)

void APlacedEditorUtilityBase::ClearActorSelectionSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "ClearActorSelectionSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.PlacedEditorUtilityBase.GetActorReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PathToActor                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* APlacedEditorUtilityBase::GetActorReference(const class FString& PathToActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "GetActorReference");

	Params::PlacedEditorUtilityBase_GetActorReference Parms{};

	Parms.PathToActor = std::move(PathToActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.PlacedEditorUtilityBase.GetLevelViewportCameraInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          CameraLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CameraRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlacedEditorUtilityBase::GetLevelViewportCameraInfo(struct FVector* CameraLocation, struct FRotator* CameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "GetLevelViewportCameraInfo");

	Params::PlacedEditorUtilityBase_GetLevelViewportCameraInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CameraLocation != nullptr)
		*CameraLocation = std::move(Parms.CameraLocation);

	if (CameraRotation != nullptr)
		*CameraRotation = std::move(Parms.CameraRotation);

	return Parms.ReturnValue;
}


// Function Blutility.PlacedEditorUtilityBase.GetSelectionSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> APlacedEditorUtilityBase::GetSelectionSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "GetSelectionSet");

	Params::PlacedEditorUtilityBase_GetSelectionSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Blutility.PlacedEditorUtilityBase.SelectNothing
// (Final, Native, Public, BlueprintCallable)

void APlacedEditorUtilityBase::SelectNothing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "SelectNothing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.PlacedEditorUtilityBase.SetActorSelectionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBeSelected                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlacedEditorUtilityBase::SetActorSelectionState(class AActor* Actor, bool bShouldBeSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "SetActorSelectionState");

	Params::PlacedEditorUtilityBase_SetActorSelectionState Parms{};

	Parms.Actor = Actor;
	Parms.bShouldBeSelected = bShouldBeSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Blutility.PlacedEditorUtilityBase.SetLevelViewportCameraInfo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CameraLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CameraRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlacedEditorUtilityBase::SetLevelViewportCameraInfo(const struct FVector& CameraLocation, const struct FRotator& CameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlacedEditorUtilityBase", "SetLevelViewportCameraInfo");

	Params::PlacedEditorUtilityBase_SetLevelViewportCameraInfo Parms{};

	Parms.CameraLocation = std::move(CameraLocation);
	Parms.CameraRotation = std::move(CameraRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

