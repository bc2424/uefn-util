#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CreativeTests

#include "Basic.hpp"

#include "CreativeTests_classes.hpp"
#include "CreativeTests_parameters.hpp"


namespace SDK
{

// Function CreativeTests.CreativeFunctionalTest.GetCreatedDevices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   OutCreatedDevices                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACreativeFunctionalTest::GetCreatedDevices(TArray<class AActor*>* OutCreatedDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "GetCreatedDevices");

	Params::CreativeFunctionalTest_GetCreatedDevices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCreatedDevices != nullptr)
		*OutCreatedDevices = std::move(Parms.OutCreatedDevices);

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTest.GetCreatedDevicesOfClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               DeviceClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutCreatedDevices                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACreativeFunctionalTest::GetCreatedDevicesOfClass(TSubclassOf<class AActor> DeviceClass, TArray<class AActor*>* OutCreatedDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "GetCreatedDevicesOfClass");

	Params::CreativeFunctionalTest_GetCreatedDevicesOfClass Parms{};

	Parms.DeviceClass = DeviceClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCreatedDevices != nullptr)
		*OutCreatedDevices = std::move(Parms.OutCreatedDevices);

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTest.HandleConditionSatisfiedChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UCreativeFunctionalTestConditionComponentBase*Condition                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACreativeFunctionalTest::HandleConditionSatisfiedChange(class UCreativeFunctionalTestConditionComponentBase* Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "HandleConditionSatisfiedChange");

	Params::CreativeFunctionalTest_HandleConditionSatisfiedChange Parms{};

	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTest.OnLevelRecordFinishSpawning
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class AActor*>                   NewlySpawnedActors                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACreativeFunctionalTest::OnLevelRecordFinishSpawning(const TArray<class AActor*>& NewlySpawnedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "OnLevelRecordFinishSpawning");

	Params::CreativeFunctionalTest_OnLevelRecordFinishSpawning Parms{};

	Parms.NewlySpawnedActors = std::move(NewlySpawnedActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTest.OnMinigameStateChanged
// (Final, Native, Private)
// Parameters:
// class AFortMinigame*                    Minigame                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFortMinigameState                      NewMinigameState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACreativeFunctionalTest::OnMinigameStateChanged(class AFortMinigame* Minigame, EFortMinigameState NewMinigameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "OnMinigameStateChanged");

	Params::CreativeFunctionalTest_OnMinigameStateChanged Parms{};

	Parms.Minigame = Minigame;
	Parms.NewMinigameState = NewMinigameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTest.CheckIfAllConditionsSatisifed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACreativeFunctionalTest::CheckIfAllConditionsSatisifed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "CheckIfAllConditionsSatisifed");

	Params::CreativeFunctionalTest_CheckIfAllConditionsSatisifed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTest.GetPlayerControllerForTest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* ACreativeFunctionalTest::GetPlayerControllerForTest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTest", "GetPlayerControllerForTest");

	Params::CreativeFunctionalTest_GetPlayerControllerForTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponentBase.CleanupAfterTest
// (Native, Event, Public, BlueprintEvent)

void UCreativeFunctionalTestConditionComponentBase::CleanupAfterTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponentBase", "CleanupAfterTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponentBase.SetConditionSatisfied
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreativeFunctionalTestConditionComponentBase::SetConditionSatisfied(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponentBase", "SetConditionSatisfied");

	Params::CreativeFunctionalTestConditionComponentBase_SetConditionSatisfied Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponentBase.SetupForTest
// (Native, Event, Public, BlueprintEvent)

void UCreativeFunctionalTestConditionComponentBase::SetupForTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponentBase", "SetupForTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponentBase.ConditionHasBeenSatisfied
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCreativeFunctionalTestConditionComponentBase::ConditionHasBeenSatisfied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponentBase", "ConditionHasBeenSatisfied");

	Params::CreativeFunctionalTestConditionComponentBase_ConditionHasBeenSatisfied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponentBase.GetTestResult
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           TestMessage                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCreativeFunctionalTestConditionComponentBase::GetTestResult(class FString* TestMessage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponentBase", "GetTestResult");

	Params::CreativeFunctionalTestConditionComponentBase_GetTestResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TestMessage != nullptr)
		*TestMessage = std::move(Parms.TestMessage);

	return Parms.ReturnValue;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponent_ReceiveOnChannel.OnReceiveOnChannel
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreativeFunctionalTestConditionComponent_ReceiveOnChannel::OnReceiveOnChannel(class AController* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponent_ReceiveOnChannel", "OnReceiveOnChannel");

	Params::CreativeFunctionalTestConditionComponent_ReceiveOnChannel_OnReceiveOnChannel Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.CreativeFunctionalTestConditionComponent_ReceiveOnChannel.SetChannelId
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            NewChannelIds                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCreativeFunctionalTestConditionComponent_ReceiveOnChannel::SetChannelId(const struct FGameplayTagContainer& NewChannelIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeFunctionalTestConditionComponent_ReceiveOnChannel", "SetChannelId");

	Params::CreativeFunctionalTestConditionComponent_ReceiveOnChannel_SetChannelId Parms{};

	Parms.NewChannelIds = std::move(NewChannelIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest.SetFunctionalTest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACreativeFunctionalTest*          FunctionalTest_0                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CreativeFunctionalTest::SetFunctionalTest(class ACreativeFunctionalTest* FunctionalTest_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest", "SetFunctionalTest");

	Params::FortControllerComponent_CreativeFunctionalTest_SetFunctionalTest Parms{};

	Parms.FunctionalTest_0 = FunctionalTest_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest.TryInteractUseForActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToUse                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFortControllerComponent_Interaction*InteractComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFortControllerComponent_CreativeFunctionalTest::TryInteractUseForActor(class AActor* ActorToUse, class UFortControllerComponent_Interaction* InteractComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest", "TryInteractUseForActor");

	Params::FortControllerComponent_CreativeFunctionalTest_TryInteractUseForActor Parms{};

	Parms.ActorToUse = ActorToUse;
	Parms.InteractComponent = InteractComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest.CanInteractWithActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ActorToUse                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFortControllerComponent_Interaction*InteractComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFortControllerComponent_CreativeFunctionalTest::CanInteractWithActor(class AActor* ActorToUse, class UFortControllerComponent_Interaction* InteractComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest", "CanInteractWithActor");

	Params::FortControllerComponent_CreativeFunctionalTest_CanInteractWithActor Parms{};

	Parms.ActorToUse = ActorToUse;
	Parms.InteractComponent = InteractComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon.ClientStartPawnFireWeapon
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class UFortWeaponItemDefinition*        ItemDefThatShouldBeEquipped                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinAmmoToFire                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon::ClientStartPawnFireWeapon(const class UFortWeaponItemDefinition* ItemDefThatShouldBeEquipped, int32 MinAmmoToFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon", "ClientStartPawnFireWeapon");

	Params::FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon_ClientStartPawnFireWeapon Parms{};

	Parms.ItemDefThatShouldBeEquipped = ItemDefThatShouldBeEquipped;
	Parms.MinAmmoToFire = MinAmmoToFire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon.ClientStopFiring
// (Net, NetReliable, Native, Event, Public, NetClient)

void UFortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon::ClientStopFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon", "ClientStopFiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon.EquipPawnAndFireWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFortWeaponItemDefinition*        ItemDefToEquip                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(ECreativeFunctionalTest_StopFireReason StopFireReason, class AFortPlayerPawn* PlayerPawnThatStoppedFiring)>StoppingFireDelegate                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeUntilStopFire                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinBulletsToFire                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon::EquipPawnAndFireWeapon(const class UFortWeaponItemDefinition* ItemDefToEquip, TDelegate<void(ECreativeFunctionalTest_StopFireReason StopFireReason, class AFortPlayerPawn* PlayerPawnThatStoppedFiring)> StoppingFireDelegate, int32 ItemLevel, float TimeUntilStopFire, int32 MinBulletsToFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon", "EquipPawnAndFireWeapon");

	Params::FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon_EquipPawnAndFireWeapon Parms{};

	Parms.ItemDefToEquip = ItemDefToEquip;
	Parms.StoppingFireDelegate = StoppingFireDelegate;
	Parms.ItemLevel = ItemLevel;
	Parms.TimeUntilStopFire = TimeUntilStopFire;
	Parms.MinBulletsToFire = MinBulletsToFire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon.ServerPawnStartedFiringWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer)

void UFortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon::ServerPawnStartedFiringWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon", "ServerPawnStartedFiringWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CreativeTests.FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon.ServerSetStopFireReason
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// ECreativeFunctionalTest_StopFireReason  StopFireReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon::ServerSetStopFireReason(ECreativeFunctionalTest_StopFireReason StopFireReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon", "ServerSetStopFireReason");

	Params::FortControllerComponent_CreativeFunctionalTest_EquipAndFireWeapon_ServerSetStopFireReason Parms{};

	Parms.StopFireReason = StopFireReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

