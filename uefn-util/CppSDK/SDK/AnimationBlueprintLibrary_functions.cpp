#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AnimationBlueprintLibrary

#include "Basic.hpp"

#include "AnimationBlueprintLibrary_classes.hpp"
#include "AnimationBlueprintLibrary_parameters.hpp"


namespace SDK
{

// Function AnimationBlueprintLibrary.AnimationAttributeBlueprintLibrary.GetAttributeKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAnimationDataModel>AnimationDataModel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAttributeBlueprintLibrary::GetAttributeKey(TScriptInterface<class IAnimationDataModel> AnimationDataModel, const struct FAnimationAttributeIdentifier& AttributeIdentifier, float Time, int32* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationAttributeBlueprintLibrary", "GetAttributeKey");

	Params::AnimationAttributeBlueprintLibrary_GetAttributeKey Parms{};

	Parms.AnimationDataModel = AnimationDataModel;
	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationAttributeBlueprintLibrary.GetAttributeKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAnimationDataModel>AnimationDataModel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           OutTimes                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAttributeBlueprintLibrary::GetAttributeKeys(TScriptInterface<class IAnimationDataModel> AnimationDataModel, const struct FAnimationAttributeIdentifier& AttributeIdentifier, TArray<float>* OutTimes, TArray<int32>* Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationAttributeBlueprintLibrary", "GetAttributeKeys");

	Params::AnimationAttributeBlueprintLibrary_GetAttributeKeys Parms{};

	Parms.AnimationDataModel = AnimationDataModel;
	Parms.AttributeIdentifier = std::move(AttributeIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTimes != nullptr)
		*OutTimes = std::move(Parms.OutTimes);

	if (Values != nullptr)
		*Values = std::move(Parms.Values);

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationAttributeBlueprintLibrary.SetAttributeKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAnimationDataController>AnimationDataController                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAttributeBlueprintLibrary::SetAttributeKey(TScriptInterface<class IAnimationDataController> AnimationDataController, const struct FAnimationAttributeIdentifier& AttributeIdentifier, float Time, const int32& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationAttributeBlueprintLibrary", "SetAttributeKey");

	Params::AnimationAttributeBlueprintLibrary_SetAttributeKey Parms{};

	Parms.AnimationDataController = AnimationDataController;
	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.Time = Time;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationAttributeBlueprintLibrary.SetAttributeKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class IAnimationDataController>AnimationDataController                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAttributeBlueprintLibrary::SetAttributeKeys(TScriptInterface<class IAnimationDataController> AnimationDataController, const struct FAnimationAttributeIdentifier& AttributeIdentifier, const TArray<float>& Times, const TArray<int32>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationAttributeBlueprintLibrary", "SetAttributeKeys");

	Params::AnimationAttributeBlueprintLibrary_SetAttributeKeys Parms{};

	Parms.AnimationDataController = AnimationDataController;
	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.Times = std::move(Times);
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationNotifyEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          NotifyClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimNotify*                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimNotify* UAnimationBlueprintLibrary::AddAnimationNotifyEvent(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName, float StartTime, TSubclassOf<class UAnimNotify> NotifyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationNotifyEvent");

	Params::AnimationBlueprintLibrary_AddAnimationNotifyEvent Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;
	Parms.StartTime = StartTime;
	Parms.NotifyClass = NotifyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationNotifyEventObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddAnimationNotifyEventObject(class UAnimSequenceBase* AnimationSequenceBase, float StartTime, const class UAnimNotify* Notify, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationNotifyEventObject");

	Params::AnimationBlueprintLibrary_AddAnimationNotifyEventObject Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.StartTime = StartTime;
	Parms.Notify = Notify;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationNotifyStateEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     NotifyStateClass                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAnimNotifyState*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAnimNotifyState* UAnimationBlueprintLibrary::AddAnimationNotifyStateEvent(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName, float StartTime, float Duration, TSubclassOf<class UAnimNotifyState> NotifyStateClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationNotifyStateEvent");

	Params::AnimationBlueprintLibrary_AddAnimationNotifyStateEvent Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;
	Parms.StartTime = StartTime;
	Parms.Duration = Duration;
	Parms.NotifyStateClass = NotifyStateClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationNotifyStateEventObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimNotifyState*                 NotifyState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddAnimationNotifyStateEventObject(class UAnimSequenceBase* AnimationSequenceBase, float StartTime, float Duration, const class UAnimNotifyState* NotifyState, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationNotifyStateEventObject");

	Params::AnimationBlueprintLibrary_AddAnimationNotifyStateEventObject Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.StartTime = StartTime;
	Parms.Duration = Duration;
	Parms.NotifyState = NotifyState;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationNotifyTrack
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TrackColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddAnimationNotifyTrack(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName, const struct FLinearColor& TrackColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationNotifyTrack");

	Params::AnimationBlueprintLibrary_AddAnimationNotifyTrack Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;
	Parms.TrackColor = std::move(TrackColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddAnimationSyncMarker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MarkerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddAnimationSyncMarker(class UAnimSequence* AnimationSequence, class FName MarkerName, float Time, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddAnimationSyncMarker");

	Params::AnimationBlueprintLibrary_AddAnimationSyncMarker Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.MarkerName = MarkerName;
	Parms.Time = Time;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     CurveType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMetaDataCurve                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddCurve(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, ERawCurveTrackTypes CurveType, bool bMetaDataCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddCurve");

	Params::AnimationBlueprintLibrary_AddCurve Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.CurveType = CurveType;
	Parms.bMetaDataCurve = bMetaDataCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddFloatCurveKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddFloatCurveKey(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const float Time, const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddFloatCurveKey");

	Params::AnimationBlueprintLibrary_AddFloatCurveKey Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Time = Time;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddFloatCurveKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddFloatCurveKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const TArray<float>& Times, const TArray<float>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddFloatCurveKeys");

	Params::AnimationBlueprintLibrary_AddFloatCurveKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Times = std::move(Times);
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddMetaData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimMetaData>        MetaDataClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    MetaDataInstance                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddMetaData(class UAnimationAsset* AnimationAsset, TSubclassOf<class UAnimMetaData> MetaDataClass, class UAnimMetaData** MetaDataInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddMetaData");

	Params::AnimationBlueprintLibrary_AddMetaData Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MetaDataInstance != nullptr)
		*MetaDataInstance = Parms.MetaDataInstance;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddMetaDataObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    MetaDataObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddMetaDataObject(class UAnimationAsset* AnimationAsset, class UAnimMetaData* MetaDataObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddMetaDataObject");

	Params::AnimationBlueprintLibrary_AddMetaDataObject Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataObject = MetaDataObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddNodeAssetOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimBlueprint*                   AnimBlueprint                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  Override                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintAppliedOverrides                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddNodeAssetOverride(class UAnimBlueprint* AnimBlueprint, const class UAnimationAsset* Target, class UAnimationAsset* Override, bool bPrintAppliedOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddNodeAssetOverride");

	Params::AnimationBlueprintLibrary_AddNodeAssetOverride Parms{};

	Parms.AnimBlueprint = AnimBlueprint;
	Parms.Target = Target;
	Parms.Override = Override;
	Parms.bPrintAppliedOverrides = bPrintAppliedOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddTransformationCurveKey
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddTransformationCurveKey(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const float Time, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddTransformationCurveKey");

	Params::AnimationBlueprintLibrary_AddTransformationCurveKey Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Time = Time;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddTransformationCurveKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               Transforms                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddTransformationCurveKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const TArray<float>& Times, const TArray<struct FTransform>& Transforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddTransformationCurveKeys");

	Params::AnimationBlueprintLibrary_AddTransformationCurveKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Times = std::move(Times);
	Parms.Transforms = std::move(Transforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddVectorCurveKey
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Vector                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddVectorCurveKey(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const float Time, const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddVectorCurveKey");

	Params::AnimationBlueprintLibrary_AddVectorCurveKey Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Time = Time;
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddVectorCurveKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Vectors                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddVectorCurveKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, const TArray<float>& Times, const TArray<struct FVector>& Vectors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddVectorCurveKeys");

	Params::AnimationBlueprintLibrary_AddVectorCurveKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Times = std::move(Times);
	Parms.Vectors = std::move(Vectors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.AddVirtualBone
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SourceBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VirtualBoneName                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::AddVirtualBone(const class UAnimSequence* AnimationSequence, class FName SourceBoneName, class FName TargetBoneName, class FName* VirtualBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "AddVirtualBone");

	Params::AnimationBlueprintLibrary_AddVirtualBone Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.SourceBoneName = SourceBoneName;
	Parms.TargetBoneName = TargetBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (VirtualBoneName != nullptr)
		*VirtualBoneName = Parms.VirtualBoneName;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.ContainsMetaDataOfClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimMetaData>        MetaDataClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::ContainsMetaDataOfClass(const class UAnimationAsset* AnimationAsset, TSubclassOf<class UAnimMetaData> MetaDataClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "ContainsMetaDataOfClass");

	Params::AnimationBlueprintLibrary_ContainsMetaDataOfClass Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.CopyAnimationCurveNamesToSkeleton
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeleton*                        OldSkeleton                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeleton*                        NewSkeleton                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                SequenceBase                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     CurveType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::CopyAnimationCurveNamesToSkeleton(class USkeleton* OldSkeleton, class USkeleton* NewSkeleton, class UAnimSequenceBase* SequenceBase, ERawCurveTrackTypes CurveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "CopyAnimationCurveNamesToSkeleton");

	Params::AnimationBlueprintLibrary_CopyAnimationCurveNamesToSkeleton Parms{};

	Parms.OldSkeleton = OldSkeleton;
	Parms.NewSkeleton = NewSkeleton;
	Parms.SequenceBase = SequenceBase;
	Parms.CurveType = CurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.CopyAnimNotifiesFromSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                SourceAnimationSequenceBase                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                DestinationAnimationSequenceBase                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeleteExistingNotifies                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::CopyAnimNotifiesFromSequence(class UAnimSequenceBase* SourceAnimationSequenceBase, class UAnimSequenceBase* DestinationAnimationSequenceBase, bool bDeleteExistingNotifies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "CopyAnimNotifiesFromSequence");

	Params::AnimationBlueprintLibrary_CopyAnimNotifiesFromSequence Parms{};

	Parms.SourceAnimationSequenceBase = SourceAnimationSequenceBase;
	Parms.DestinationAnimationSequenceBase = DestinationAnimationSequenceBase;
	Parms.bDeleteExistingNotifies = bDeleteExistingNotifies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.DoesBoneNameExist
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExists                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::DoesBoneNameExist(class UAnimSequence* AnimationSequence, class FName BoneName, bool* bExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "DoesBoneNameExist");

	Params::AnimationBlueprintLibrary_DoesBoneNameExist Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bExists != nullptr)
		*bExists = Parms.bExists;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.DoesCurveExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     CurveType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::DoesCurveExist(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, ERawCurveTrackTypes CurveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "DoesCurveExist");

	Params::AnimationBlueprintLibrary_DoesCurveExist Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.CurveType = CurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.EvaluateRootBoneTimecodeAttributesAtTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EvalTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQualifiedFrameTime              OutQualifiedFrameTime                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::EvaluateRootBoneTimecodeAttributesAtTime(const class UAnimSequenceBase* AnimationSequenceBase, const float EvalTime, struct FQualifiedFrameTime* OutQualifiedFrameTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "EvaluateRootBoneTimecodeAttributesAtTime");

	Params::AnimationBlueprintLibrary_EvaluateRootBoneTimecodeAttributesAtTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.EvalTime = EvalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutQualifiedFrameTime != nullptr)
		*OutQualifiedFrameTime = std::move(Parms.OutQualifiedFrameTime);

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.EvaluateRootBoneTimecodeSubframeAttributeAtTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EvalTime                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSubframe                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::EvaluateRootBoneTimecodeSubframeAttributeAtTime(const class UAnimSequenceBase* AnimationSequenceBase, const float EvalTime, float* OutSubframe)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "EvaluateRootBoneTimecodeSubframeAttributeAtTime");

	Params::AnimationBlueprintLibrary_EvaluateRootBoneTimecodeSubframeAttributeAtTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.EvalTime = EvalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSubframe != nullptr)
		*OutSubframe = Parms.OutSubframe;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.ExtractRootTrackTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAnimationBlueprintLibrary::ExtractRootTrackTransform(const class UAnimSequenceBase* AnimationSequenceBase, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "ExtractRootTrackTransform");

	Params::AnimationBlueprintLibrary_ExtractRootTrackTransform Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.FinalizeBoneAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::FinalizeBoneAnimation(class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "FinalizeBoneAnimation");

	Params::AnimationBlueprintLibrary_FinalizeBoneAnimation Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.FindBonePathToRoot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BonePath                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::FindBonePathToRoot(const class UAnimSequenceBase* AnimationSequenceBase, class FName BoneName, TArray<class FName>* BonePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "FindBonePathToRoot");

	Params::AnimationBlueprintLibrary_FindBonePathToRoot Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BonePath != nullptr)
		*BonePath = std::move(Parms.BonePath);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAdditiveAnimationType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAdditiveAnimationType                  AdditiveAnimationType                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAdditiveAnimationType(const class UAnimSequence* AnimationSequence, EAdditiveAnimationType* AdditiveAnimationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAdditiveAnimationType");

	Params::AnimationBlueprintLibrary_GetAdditiveAnimationType Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AdditiveAnimationType != nullptr)
		*AdditiveAnimationType = Parms.AdditiveAnimationType;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAdditiveBasePoseType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAdditiveBasePoseType                   AdditiveBasePoseType                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAdditiveBasePoseType(const class UAnimSequence* AnimationSequence, EAdditiveBasePoseType* AdditiveBasePoseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAdditiveBasePoseType");

	Params::AnimationBlueprintLibrary_GetAdditiveBasePoseType Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AdditiveBasePoseType != nullptr)
		*AdditiveBasePoseType = Parms.AdditiveBasePoseType;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationCurveNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     CurveType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     CurveNames                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationCurveNames(const class UAnimSequenceBase* AnimationSequenceBase, ERawCurveTrackTypes CurveType, TArray<class FName>* CurveNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationCurveNames");

	Params::AnimationBlueprintLibrary_GetAnimationCurveNames Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveType = CurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurveNames != nullptr)
		*CurveNames = std::move(Parms.CurveNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationGraphs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimBlueprint*                   AnimationBlueprint                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimationGraph*>          AnimationGraphs                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationGraphs(class UAnimBlueprint* AnimationBlueprint, TArray<class UAnimationGraph*>* AnimationGraphs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationGraphs");

	Params::AnimationBlueprintLibrary_GetAnimationGraphs Parms{};

	Parms.AnimationBlueprint = AnimationBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimationGraphs != nullptr)
		*AnimationGraphs = std::move(Parms.AnimationGraphs);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationInterpolationType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimInterpolationType                  InterpolationType                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationInterpolationType(const class UAnimSequence* AnimationSequence, EAnimInterpolationType* InterpolationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationInterpolationType");

	Params::AnimationBlueprintLibrary_GetAnimationInterpolationType Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InterpolationType != nullptr)
		*InterpolationType = Parms.InterpolationType;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationNotifyEventNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     EventNames                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationNotifyEventNames(const class UAnimSequenceBase* AnimationSequenceBase, TArray<class FName>* EventNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationNotifyEventNames");

	Params::AnimationBlueprintLibrary_GetAnimationNotifyEventNames Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EventNames != nullptr)
		*EventNames = std::move(Parms.EventNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationNotifyEvents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         NotifyEvents                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationNotifyEvents(const class UAnimSequenceBase* AnimationSequenceBase, TArray<struct FAnimNotifyEvent>* NotifyEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationNotifyEvents");

	Params::AnimationBlueprintLibrary_GetAnimationNotifyEvents Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NotifyEvents != nullptr)
		*NotifyEvents = std::move(Parms.NotifyEvents);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationNotifyEventsForTrack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         Events                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationNotifyEventsForTrack(const class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName, TArray<struct FAnimNotifyEvent>* Events)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationNotifyEventsForTrack");

	Params::AnimationBlueprintLibrary_GetAnimationNotifyEventsForTrack Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Events != nullptr)
		*Events = std::move(Parms.Events);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationNotifyTrackNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     TrackNames                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationNotifyTrackNames(const class UAnimSequenceBase* AnimationSequenceBase, TArray<class FName>* TrackNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationNotifyTrackNames");

	Params::AnimationBlueprintLibrary_GetAnimationNotifyTrackNames Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TrackNames != nullptr)
		*TrackNames = std::move(Parms.TrackNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationSyncMarkers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimSyncMarker>          Markers                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationSyncMarkers(const class UAnimSequence* AnimationSequence, TArray<struct FAnimSyncMarker>* Markers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationSyncMarkers");

	Params::AnimationBlueprintLibrary_GetAnimationSyncMarkers Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Markers != nullptr)
		*Markers = std::move(Parms.Markers);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationSyncMarkersForTrack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimSyncMarker>          Markers                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationSyncMarkersForTrack(const class UAnimSequence* AnimationSequence, class FName NotifyTrackName, TArray<struct FAnimSyncMarker>* Markers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationSyncMarkersForTrack");

	Params::AnimationBlueprintLibrary_GetAnimationSyncMarkersForTrack Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Markers != nullptr)
		*Markers = std::move(Parms.Markers);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimationTrackNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     TrackNames                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetAnimationTrackNames(const class UAnimSequenceBase* AnimationSequenceBase, TArray<class FName>* TrackNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimationTrackNames");

	Params::AnimationBlueprintLibrary_GetAnimationTrackNames Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TrackNames != nullptr)
		*TrackNames = std::move(Parms.TrackNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimNotifyEventDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEvent                 NotifyEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationBlueprintLibrary::GetAnimNotifyEventDuration(const struct FAnimNotifyEvent& NotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimNotifyEventDuration");

	Params::AnimationBlueprintLibrary_GetAnimNotifyEventDuration Parms{};

	Parms.NotifyEvent = std::move(NotifyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetAnimNotifyEventTriggerTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEvent                 NotifyEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationBlueprintLibrary::GetAnimNotifyEventTriggerTime(const struct FAnimNotifyEvent& NotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetAnimNotifyEventTriggerTime");

	Params::AnimationBlueprintLibrary_GetAnimNotifyEventTriggerTime Parms{};

	Parms.NotifyEvent = std::move(NotifyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetBoneCompressionSettings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimBoneCompressionSettings*     CompressionSettings                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetBoneCompressionSettings(const class UAnimSequence* AnimationSequence, class UAnimBoneCompressionSettings** CompressionSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetBoneCompressionSettings");

	Params::AnimationBlueprintLibrary_GetBoneCompressionSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CompressionSettings != nullptr)
		*CompressionSettings = Parms.CompressionSettings;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetBonePoseForFrame
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Pose                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetBonePoseForFrame(const class UAnimSequenceBase* AnimationSequenceBase, class FName BoneName, int32 Frame, bool bExtractRootMotion, struct FTransform* Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetBonePoseForFrame");

	Params::AnimationBlueprintLibrary_GetBonePoseForFrame Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneName = BoneName;
	Parms.Frame = Frame;
	Parms.bExtractRootMotion = bExtractRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Pose != nullptr)
		*Pose = std::move(Parms.Pose);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetBonePoseForTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Pose                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetBonePoseForTime(const class UAnimSequenceBase* AnimationSequenceBase, class FName BoneName, float Time, bool bExtractRootMotion, struct FTransform* Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetBonePoseForTime");

	Params::AnimationBlueprintLibrary_GetBonePoseForTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneName = BoneName;
	Parms.Time = Time;
	Parms.bExtractRootMotion = bExtractRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Pose != nullptr)
		*Pose = std::move(Parms.Pose);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetBonePosesForFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneNames                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               Poses                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    PreviewMesh                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetBonePosesForFrame(const class UAnimSequenceBase* AnimationSequenceBase, const TArray<class FName>& BoneNames, int32 Frame, bool bExtractRootMotion, TArray<struct FTransform>* Poses, const class USkeletalMesh* PreviewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetBonePosesForFrame");

	Params::AnimationBlueprintLibrary_GetBonePosesForFrame Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneNames = std::move(BoneNames);
	Parms.Frame = Frame;
	Parms.bExtractRootMotion = bExtractRootMotion;
	Parms.PreviewMesh = PreviewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Poses != nullptr)
		*Poses = std::move(Parms.Poses);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetBonePosesForTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneNames                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExtractRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               Poses                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    PreviewMesh                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetBonePosesForTime(const class UAnimSequenceBase* AnimationSequenceBase, const TArray<class FName>& BoneNames, float Time, bool bExtractRootMotion, TArray<struct FTransform>* Poses, const class USkeletalMesh* PreviewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetBonePosesForTime");

	Params::AnimationBlueprintLibrary_GetBonePosesForTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.BoneNames = std::move(BoneNames);
	Parms.Time = Time;
	Parms.bExtractRootMotion = bExtractRootMotion;
	Parms.PreviewMesh = PreviewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Poses != nullptr)
		*Poses = std::move(Parms.Poses);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetCurveCompressionSettings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimCurveCompressionSettings*    CompressionSettings                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetCurveCompressionSettings(const class UAnimSequence* AnimationSequence, class UAnimCurveCompressionSettings** CompressionSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetCurveCompressionSettings");

	Params::AnimationBlueprintLibrary_GetCurveCompressionSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CompressionSettings != nullptr)
		*CompressionSettings = Parms.CompressionSettings;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetFloatKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetFloatKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, TArray<float>* Times, TArray<float>* Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetFloatKeys");

	Params::AnimationBlueprintLibrary_GetFloatKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Times != nullptr)
		*Times = std::move(Parms.Times);

	if (Values != nullptr)
		*Values = std::move(Parms.Values);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetFloatValueAtTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationBlueprintLibrary::GetFloatValueAtTime(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetFloatValueAtTime");

	Params::AnimationBlueprintLibrary_GetFloatValueAtTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetFrameAtTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Frame                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetFrameAtTime(const class UAnimSequenceBase* AnimationSequenceBase, const float Time, int32* Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetFrameAtTime");

	Params::AnimationBlueprintLibrary_GetFrameAtTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Frame != nullptr)
		*Frame = Parms.Frame;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetMetaData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimMetaData*>            MetaData                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetMetaData(const class UAnimationAsset* AnimationAsset, TArray<class UAnimMetaData*>* MetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetMetaData");

	Params::AnimationBlueprintLibrary_GetMetaData Parms{};

	Parms.AnimationAsset = AnimationAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MetaData != nullptr)
		*MetaData = std::move(Parms.MetaData);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetMetaDataOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimMetaData>        MetaDataClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimMetaData*>            MetaDataOfClass                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetMetaDataOfClass(const class UAnimationAsset* AnimationAsset, TSubclassOf<class UAnimMetaData> MetaDataClass, TArray<class UAnimMetaData*>* MetaDataOfClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetMetaDataOfClass");

	Params::AnimationBlueprintLibrary_GetMetaDataOfClass Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MetaDataOfClass != nullptr)
		*MetaDataOfClass = std::move(Parms.MetaDataOfClass);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetMontageSlotNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     AnimationMontage                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SlotNames                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetMontageSlotNames(const class UAnimMontage* AnimationMontage, TArray<class FName>* SlotNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetMontageSlotNames");

	Params::AnimationBlueprintLibrary_GetMontageSlotNames Parms{};

	Parms.AnimationMontage = AnimationMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SlotNames != nullptr)
		*SlotNames = std::move(Parms.SlotNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetNodesOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimBlueprint*                   AnimationBlueprint                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimGraphNode_Base>  NodeClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimGraphNode_Base*>      GraphNodes                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildClasses                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetNodesOfClass(class UAnimBlueprint* AnimationBlueprint, TSubclassOf<class UAnimGraphNode_Base> NodeClass, TArray<class UAnimGraphNode_Base*>* GraphNodes, bool bIncludeChildClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetNodesOfClass");

	Params::AnimationBlueprintLibrary_GetNodesOfClass Parms{};

	Parms.AnimationBlueprint = AnimationBlueprint;
	Parms.NodeClass = NodeClass;
	Parms.bIncludeChildClasses = bIncludeChildClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GraphNodes != nullptr)
		*GraphNodes = std::move(Parms.GraphNodes);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetNumFrames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumFrames                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetNumFrames(const class UAnimSequenceBase* AnimationSequenceBase, int32* NumFrames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetNumFrames");

	Params::AnimationBlueprintLibrary_GetNumFrames Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NumFrames != nullptr)
		*NumFrames = Parms.NumFrames;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetNumKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumKeys                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetNumKeys(const class UAnimSequenceBase* AnimationSequenceBase, int32* NumKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetNumKeys");

	Params::AnimationBlueprintLibrary_GetNumKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NumKeys != nullptr)
		*NumKeys = Parms.NumKeys;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRateScale
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRateScale(const class UAnimSequenceBase* AnimationSequenceBase, float* RateScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRateScale");

	Params::AnimationBlueprintLibrary_GetRateScale Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RateScale != nullptr)
		*RateScale = Parms.RateScale;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRawTrackData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrackName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PositionKeys                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    RotationKeys                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ScalingKeys                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRawTrackData(const class UAnimSequenceBase* AnimationSequenceBase, const class FName TrackName, TArray<struct FVector>* PositionKeys, TArray<struct FQuat>* RotationKeys, TArray<struct FVector>* ScalingKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRawTrackData");

	Params::AnimationBlueprintLibrary_GetRawTrackData Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.TrackName = TrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PositionKeys != nullptr)
		*PositionKeys = std::move(Parms.PositionKeys);

	if (RotationKeys != nullptr)
		*RotationKeys = std::move(Parms.RotationKeys);

	if (ScalingKeys != nullptr)
		*ScalingKeys = std::move(Parms.ScalingKeys);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRawTrackPositionData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrackName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PositionData                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRawTrackPositionData(const class UAnimSequenceBase* AnimationSequenceBase, const class FName TrackName, TArray<struct FVector>* PositionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRawTrackPositionData");

	Params::AnimationBlueprintLibrary_GetRawTrackPositionData Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.TrackName = TrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PositionData != nullptr)
		*PositionData = std::move(Parms.PositionData);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRawTrackRotationData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrackName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    RotationData                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRawTrackRotationData(const class UAnimSequenceBase* AnimationSequenceBase, const class FName TrackName, TArray<struct FQuat>* RotationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRawTrackRotationData");

	Params::AnimationBlueprintLibrary_GetRawTrackRotationData Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.TrackName = TrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RotationData != nullptr)
		*RotationData = std::move(Parms.RotationData);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRawTrackScaleData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrackName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ScaleData                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRawTrackScaleData(const class UAnimSequenceBase* AnimationSequenceBase, const class FName TrackName, TArray<struct FVector>* ScaleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRawTrackScaleData");

	Params::AnimationBlueprintLibrary_GetRawTrackScaleData Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.TrackName = TrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ScaleData != nullptr)
		*ScaleData = std::move(Parms.ScaleData);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetRootMotionLockType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionRootLock                     LockType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetRootMotionLockType(const class UAnimSequence* AnimationSequence, ERootMotionRootLock* LockType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetRootMotionLockType");

	Params::AnimationBlueprintLibrary_GetRootMotionLockType Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LockType != nullptr)
		*LockType = Parms.LockType;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetSequenceLength
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetSequenceLength(const class UAnimSequenceBase* AnimationSequenceBase, float* Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetSequenceLength");

	Params::AnimationBlueprintLibrary_GetSequenceLength Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Length != nullptr)
		*Length = Parms.Length;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetTimeAtFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Frame                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetTimeAtFrame(const class UAnimSequenceBase* AnimationSequenceBase, const int32 Frame, float* Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetTimeAtFrame");

	Params::AnimationBlueprintLibrary_GetTimeAtFrame Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.Frame = Frame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Time != nullptr)
		*Time = Parms.Time;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetTransformationKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetTransformationKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, TArray<float>* Times, TArray<struct FTransform>* Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetTransformationKeys");

	Params::AnimationBlueprintLibrary_GetTransformationKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Times != nullptr)
		*Times = std::move(Parms.Times);

	if (Values != nullptr)
		*Values = std::move(Parms.Values);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetUniqueMarkerNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     MarkerNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetUniqueMarkerNames(const class UAnimSequence* AnimationSequence, TArray<class FName>* MarkerNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetUniqueMarkerNames");

	Params::AnimationBlueprintLibrary_GetUniqueMarkerNames Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MarkerNames != nullptr)
		*MarkerNames = std::move(Parms.MarkerNames);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetVariableFrameStrippingSettings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVariableFrameStrippingSettings*  VariableFrameStrippingSettings                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetVariableFrameStrippingSettings(const class UAnimSequence* AnimationSequence, class UVariableFrameStrippingSettings** VariableFrameStrippingSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetVariableFrameStrippingSettings");

	Params::AnimationBlueprintLibrary_GetVariableFrameStrippingSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (VariableFrameStrippingSettings != nullptr)
		*VariableFrameStrippingSettings = Parms.VariableFrameStrippingSettings;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.GetVectorKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Times                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::GetVectorKeys(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, TArray<float>* Times, TArray<struct FVector>* Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "GetVectorKeys");

	Params::AnimationBlueprintLibrary_GetVectorKeys Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Times != nullptr)
		*Times = std::move(Parms.Times);

	if (Values != nullptr)
		*Values = std::move(Parms.Values);
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsRootMotionEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::IsRootMotionEnabled(const class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsRootMotionEnabled");

	Params::AnimationBlueprintLibrary_IsRootMotionEnabled Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsRootMotionLockForced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::IsRootMotionLockForced(const class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsRootMotionLockForced");

	Params::AnimationBlueprintLibrary_IsRootMotionLockForced Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsValidAnimationSyncMarkerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MarkerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::IsValidAnimationSyncMarkerName(const class UAnimSequence* AnimationSequence, class FName MarkerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsValidAnimationSyncMarkerName");

	Params::AnimationBlueprintLibrary_IsValidAnimationSyncMarkerName Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.MarkerName = MarkerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsValidAnimNotifyTrackName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::IsValidAnimNotifyTrackName(const class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsValidAnimNotifyTrackName");

	Params::AnimationBlueprintLibrary_IsValidAnimNotifyTrackName Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsValidRawAnimationTrackName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TrackName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationBlueprintLibrary::IsValidRawAnimationTrackName(const class UAnimSequenceBase* AnimationSequenceBase, const class FName TrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsValidRawAnimationTrackName");

	Params::AnimationBlueprintLibrary_IsValidRawAnimationTrackName Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.TrackName = TrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.IsValidTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::IsValidTime(const class UAnimSequenceBase* AnimationSequenceBase, const float Time, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "IsValidTime");

	Params::AnimationBlueprintLibrary_IsValidTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllAnimationNotifyTracks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllAnimationNotifyTracks(class UAnimSequenceBase* AnimationSequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllAnimationNotifyTracks");

	Params::AnimationBlueprintLibrary_RemoveAllAnimationNotifyTracks Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllAnimationSyncMarkers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllAnimationSyncMarkers(class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllAnimationSyncMarkers");

	Params::AnimationBlueprintLibrary_RemoveAllAnimationSyncMarkers Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllBoneAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllBoneAnimation(class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllBoneAnimation");

	Params::AnimationBlueprintLibrary_RemoveAllBoneAnimation Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllCurveData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllCurveData(class UAnimSequenceBase* AnimationSequenceBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllCurveData");

	Params::AnimationBlueprintLibrary_RemoveAllCurveData Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllMetaData(class UAnimationAsset* AnimationAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllMetaData");

	Params::AnimationBlueprintLibrary_RemoveAllMetaData Parms{};

	Parms.AnimationAsset = AnimationAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAllVirtualBones
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAllVirtualBones(const class UAnimSequence* AnimationSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAllVirtualBones");

	Params::AnimationBlueprintLibrary_RemoveAllVirtualBones Parms{};

	Parms.AnimationSequence = AnimationSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAnimationNotifyEventsByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationBlueprintLibrary::RemoveAnimationNotifyEventsByName(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAnimationNotifyEventsByName");

	Params::AnimationBlueprintLibrary_RemoveAnimationNotifyEventsByName Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyName = NotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAnimationNotifyEventsByTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationBlueprintLibrary::RemoveAnimationNotifyEventsByTrack(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAnimationNotifyEventsByTrack");

	Params::AnimationBlueprintLibrary_RemoveAnimationNotifyEventsByTrack Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAnimationNotifyTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveAnimationNotifyTrack(class UAnimSequenceBase* AnimationSequenceBase, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAnimationNotifyTrack");

	Params::AnimationBlueprintLibrary_RemoveAnimationNotifyTrack Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAnimationSyncMarkersByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MarkerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationBlueprintLibrary::RemoveAnimationSyncMarkersByName(class UAnimSequence* AnimationSequence, class FName MarkerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAnimationSyncMarkersByName");

	Params::AnimationBlueprintLibrary_RemoveAnimationSyncMarkersByName Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.MarkerName = MarkerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveAnimationSyncMarkersByTrack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimationBlueprintLibrary::RemoveAnimationSyncMarkersByTrack(class UAnimSequence* AnimationSequence, class FName NotifyTrackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveAnimationSyncMarkersByTrack");

	Params::AnimationBlueprintLibrary_RemoveAnimationSyncMarkersByTrack Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.NotifyTrackName = NotifyTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveBoneAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinalize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveBoneAnimation(class UAnimSequence* AnimationSequence, class FName BoneName, bool bIncludeChildren, bool bFinalize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveBoneAnimation");

	Params::AnimationBlueprintLibrary_RemoveBoneAnimation Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.BoneName = BoneName;
	Parms.bIncludeChildren = bIncludeChildren;
	Parms.bFinalize = bFinalize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveNameFromSkeleton                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveCurve(class UAnimSequenceBase* AnimationSequenceBase, class FName CurveName, bool bRemoveNameFromSkeleton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveCurve");

	Params::AnimationBlueprintLibrary_RemoveCurve Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.CurveName = CurveName;
	Parms.bRemoveNameFromSkeleton = bRemoveNameFromSkeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMetaData*                    MetaDataObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveMetaData(class UAnimationAsset* AnimationAsset, class UAnimMetaData* MetaDataObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveMetaData");

	Params::AnimationBlueprintLibrary_RemoveMetaData Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataObject = MetaDataObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveMetaDataOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimMetaData>        MetaDataClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveMetaDataOfClass(class UAnimationAsset* AnimationAsset, TSubclassOf<class UAnimMetaData> MetaDataClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveMetaDataOfClass");

	Params::AnimationBlueprintLibrary_RemoveMetaDataOfClass Parms{};

	Parms.AnimationAsset = AnimationAsset;
	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveVirtualBone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VirtualBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveVirtualBone(const class UAnimSequence* AnimationSequence, class FName VirtualBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveVirtualBone");

	Params::AnimationBlueprintLibrary_RemoveVirtualBone Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.VirtualBoneName = VirtualBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.RemoveVirtualBones
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     VirtualBoneNames                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::RemoveVirtualBones(const class UAnimSequence* AnimationSequence, const TArray<class FName>& VirtualBoneNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "RemoveVirtualBones");

	Params::AnimationBlueprintLibrary_RemoveVirtualBones Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.VirtualBoneNames = std::move(VirtualBoneNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.ReplaceAnimNotifies
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          OldNotifyClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          NewNotifyClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UAnimNotify* OldNotify, class UAnimNotify* NewNotify)>OnNotifyReplaced                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::ReplaceAnimNotifies(class UAnimSequenceBase* AnimationSequenceBase, TSubclassOf<class UAnimNotify> OldNotifyClass, TSubclassOf<class UAnimNotify> NewNotifyClass, TDelegate<void(class UAnimNotify* OldNotify, class UAnimNotify* NewNotify)> OnNotifyReplaced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "ReplaceAnimNotifies");

	Params::AnimationBlueprintLibrary_ReplaceAnimNotifies Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.OldNotifyClass = OldNotifyClass;
	Parms.NewNotifyClass = NewNotifyClass;
	Parms.OnNotifyReplaced = OnNotifyReplaced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.ReplaceAnimNotifyStates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     OldNotifyClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     NewNotifyClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UAnimNotifyState* OldNotifyState, class UAnimNotifyState* NewNotifyState)>OnNotifyStateReplaced                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::ReplaceAnimNotifyStates(class UAnimSequenceBase* AnimationSequenceBase, TSubclassOf<class UAnimNotifyState> OldNotifyClass, TSubclassOf<class UAnimNotifyState> NewNotifyClass, TDelegate<void(class UAnimNotifyState* OldNotifyState, class UAnimNotifyState* NewNotifyState)> OnNotifyStateReplaced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "ReplaceAnimNotifyStates");

	Params::AnimationBlueprintLibrary_ReplaceAnimNotifyStates Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.OldNotifyClass = OldNotifyClass;
	Parms.NewNotifyClass = NewNotifyClass;
	Parms.OnNotifyStateReplaced = OnNotifyStateReplaced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetAdditiveAnimationType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAdditiveAnimationType                  AdditiveAnimationType                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetAdditiveAnimationType(class UAnimSequence* AnimationSequence, const EAdditiveAnimationType AdditiveAnimationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetAdditiveAnimationType");

	Params::AnimationBlueprintLibrary_SetAdditiveAnimationType Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.AdditiveAnimationType = AdditiveAnimationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetAdditiveBasePoseType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAdditiveBasePoseType                   AdditiveBasePoseType                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetAdditiveBasePoseType(class UAnimSequence* AnimationSequence, const EAdditiveBasePoseType AdditiveBasePoseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetAdditiveBasePoseType");

	Params::AnimationBlueprintLibrary_SetAdditiveBasePoseType Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.AdditiveBasePoseType = AdditiveBasePoseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetAnimationInterpolationType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimInterpolationType                  InterpolationType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetAnimationInterpolationType(class UAnimSequence* AnimationSequence, EAnimInterpolationType InterpolationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetAnimationInterpolationType");

	Params::AnimationBlueprintLibrary_SetAnimationInterpolationType Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.InterpolationType = InterpolationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetBoneCompressionSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimBoneCompressionSettings*     CompressionSettings                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetBoneCompressionSettings(class UAnimSequence* AnimationSequence, class UAnimBoneCompressionSettings* CompressionSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetBoneCompressionSettings");

	Params::AnimationBlueprintLibrary_SetBoneCompressionSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.CompressionSettings = CompressionSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetCurveCompressionSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimCurveCompressionSettings*    CompressionSettings                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetCurveCompressionSettings(class UAnimSequence* AnimationSequence, class UAnimCurveCompressionSettings* CompressionSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetCurveCompressionSettings");

	Params::AnimationBlueprintLibrary_SetCurveCompressionSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.CompressionSettings = CompressionSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetIsRootMotionLockForced
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetIsRootMotionLockForced(class UAnimSequence* AnimationSequence, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetIsRootMotionLockForced");

	Params::AnimationBlueprintLibrary_SetIsRootMotionLockForced Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetRateScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetRateScale(class UAnimSequenceBase* AnimationSequenceBase, float RateScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetRateScale");

	Params::AnimationBlueprintLibrary_SetRateScale Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.RateScale = RateScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetRootMotionEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetRootMotionEnabled(class UAnimSequence* AnimationSequence, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetRootMotionEnabled");

	Params::AnimationBlueprintLibrary_SetRootMotionEnabled Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetRootMotionLockType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionRootLock                     RootMotionLockType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetRootMotionLockType(class UAnimSequence* AnimationSequence, ERootMotionRootLock RootMotionLockType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetRootMotionLockType");

	Params::AnimationBlueprintLibrary_SetRootMotionLockType Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.RootMotionLockType = RootMotionLockType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimationBlueprintLibrary.SetVariableFrameStrippingSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimationSequence                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVariableFrameStrippingSettings*  VariableFrameStrippingSettings                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationBlueprintLibrary::SetVariableFrameStrippingSettings(class UAnimSequence* AnimationSequence, class UVariableFrameStrippingSettings* VariableFrameStrippingSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimationBlueprintLibrary", "SetVariableFrameStrippingSettings");

	Params::AnimationBlueprintLibrary_SetVariableFrameStrippingSettings Parms{};

	Parms.AnimationSequence = AnimationSequence;
	Parms.VariableFrameStrippingSettings = VariableFrameStrippingSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.EvaluateAnimationBlueprintWithInputPose
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimPose                        InputPose                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    TargetSkeletalMesh                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimBlueprint*                   AnimationBlueprint                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimPose                        OutPose                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::EvaluateAnimationBlueprintWithInputPose(const struct FAnimPose& InputPose, class USkeletalMesh* TargetSkeletalMesh, class UAnimBlueprint* AnimationBlueprint, struct FAnimPose* OutPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "EvaluateAnimationBlueprintWithInputPose");

	Params::AnimPoseExtensions_EvaluateAnimationBlueprintWithInputPose Parms{};

	Parms.InputPose = std::move(InputPose);
	Parms.TargetSkeletalMesh = TargetSkeletalMesh;
	Parms.AnimationBlueprint = AnimationBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPose != nullptr)
		*OutPose = std::move(Parms.OutPose);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetAnimPoseAtFrame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FrameIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimPoseEvaluationOptions       EvaluationOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAnimPose                        Pose                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetAnimPoseAtFrame(const class UAnimSequenceBase* AnimationSequenceBase, int32 FrameIndex, const struct FAnimPoseEvaluationOptions& EvaluationOptions, struct FAnimPose* Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetAnimPoseAtFrame");

	Params::AnimPoseExtensions_GetAnimPoseAtFrame Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.FrameIndex = FrameIndex;
	Parms.EvaluationOptions = std::move(EvaluationOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Pose != nullptr)
		*Pose = std::move(Parms.Pose);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetAnimPoseAtTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimationSequenceBase                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimPoseEvaluationOptions       EvaluationOptions                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAnimPose                        Pose                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetAnimPoseAtTime(const class UAnimSequenceBase* AnimationSequenceBase, double Time, const struct FAnimPoseEvaluationOptions& EvaluationOptions, struct FAnimPose* Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetAnimPoseAtTime");

	Params::AnimPoseExtensions_GetAnimPoseAtTime Parms{};

	Parms.AnimationSequenceBase = AnimationSequenceBase;
	Parms.Time = Time;
	Parms.EvaluationOptions = std::move(EvaluationOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Pose != nullptr)
		*Pose = std::move(Parms.Pose);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetBoneNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     Bones                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetBoneNames(const struct FAnimPose& Pose, TArray<class FName>* Bones)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetBoneNames");

	Params::AnimPoseExtensions_GetBoneNames Parms{};

	Parms.Pose = std::move(Pose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Bones != nullptr)
		*Bones = std::move(Parms.Bones);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetBonePose
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform UAnimPoseExtensions::GetBonePose(const struct FAnimPose& Pose, class FName BoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetBonePose");

	Params::AnimPoseExtensions_GetBonePose Parms{};

	Parms.Pose = std::move(Pose);
	Parms.BoneName = BoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetCurveNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     Curves                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetCurveNames(const struct FAnimPose& Pose, TArray<class FName>* Curves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetCurveNames");

	Params::AnimPoseExtensions_GetCurveNames Parms{};

	Parms.Pose = std::move(Pose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Curves != nullptr)
		*Curves = std::move(Parms.Curves);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetCurveWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimPoseExtensions::GetCurveWeight(const struct FAnimPose& Pose, const class FName& CurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetCurveWeight");

	Params::AnimPoseExtensions_GetCurveWeight Parms{};

	Parms.Pose = std::move(Pose);
	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetRefBonePose
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform UAnimPoseExtensions::GetRefBonePose(const struct FAnimPose& Pose, class FName BoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetRefBonePose");

	Params::AnimPoseExtensions_GetRefBonePose Parms{};

	Parms.Pose = std::move(Pose);
	Parms.BoneName = BoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetReferencePose
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeleton*                        Skeleton                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimPose                        OutPose                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetReferencePose(class USkeleton* Skeleton, struct FAnimPose* OutPose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetReferencePose");

	Params::AnimPoseExtensions_GetReferencePose Parms{};

	Parms.Skeleton = Skeleton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPose != nullptr)
		*OutPose = std::move(Parms.OutPose);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetRefPoseRelativeTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             FromBoneName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ToBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAnimPoseExtensions::GetRefPoseRelativeTransform(const struct FAnimPose& Pose, class FName FromBoneName, class FName ToBoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetRefPoseRelativeTransform");

	Params::AnimPoseExtensions_GetRefPoseRelativeTransform Parms{};

	Parms.Pose = std::move(Pose);
	Parms.FromBoneName = FromBoneName;
	Parms.ToBoneName = ToBoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetRelativeToRefPoseTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAnimPoseExtensions::GetRelativeToRefPoseTransform(const struct FAnimPose& Pose, class FName BoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetRelativeToRefPoseTransform");

	Params::AnimPoseExtensions_GetRelativeToRefPoseTransform Parms{};

	Parms.Pose = std::move(Pose);
	Parms.BoneName = BoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetRelativeTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             FromBoneName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ToBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAnimPoseExtensions::GetRelativeTransform(const struct FAnimPose& Pose, class FName FromBoneName, class FName ToBoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetRelativeTransform");

	Params::AnimPoseExtensions_GetRelativeTransform Parms{};

	Parms.Pose = std::move(Pose);
	Parms.FromBoneName = FromBoneName;
	Parms.ToBoneName = ToBoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetSocketNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     Sockets                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::GetSocketNames(const struct FAnimPose& Pose, TArray<class FName>* Sockets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetSocketNames");

	Params::AnimPoseExtensions_GetSocketNames Parms{};

	Parms.Pose = std::move(Pose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sockets != nullptr)
		*Sockets = std::move(Parms.Sockets);
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.GetSocketPose
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UAnimPoseExtensions::GetSocketPose(const struct FAnimPose& Pose, class FName SocketName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "GetSocketPose");

	Params::AnimPoseExtensions_GetSocketPose Parms{};

	Parms.Pose = std::move(Pose);
	Parms.SocketName = SocketName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimPose                        Pose                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimPoseExtensions::IsValid(const struct FAnimPose& Pose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "IsValid");

	Params::AnimPoseExtensions_IsValid Parms{};

	Parms.Pose = std::move(Pose);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AnimationBlueprintLibrary.AnimPoseExtensions.SetBonePose
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FAnimPose                        Pose                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimPoseSpaces                         Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimPoseExtensions::SetBonePose(struct FAnimPose& Pose, const struct FTransform& Transform, class FName BoneName, EAnimPoseSpaces Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AnimPoseExtensions", "SetBonePose");

	Params::AnimPoseExtensions_SetBonePose Parms{};

	Parms.Pose = std::move(Pose);
	Parms.Transform = std::move(Transform);
	Parms.BoneName = BoneName;
	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Pose = std::move(Parms.Pose);
}

}

