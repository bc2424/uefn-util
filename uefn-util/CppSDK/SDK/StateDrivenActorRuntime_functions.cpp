#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StateDrivenActorRuntime

#include "Basic.hpp"

#include "StateDrivenActorRuntime_classes.hpp"
#include "StateDrivenActorRuntime_parameters.hpp"


namespace SDK
{

// Function StateDrivenActorRuntime.ControllerComponent_StateDrivenReplication.OnRep_LatestRecordedStateTreeTransitionResult
// (Final, Native, Private)

void UControllerComponent_StateDrivenReplication::OnRep_LatestRecordedStateTreeTransitionResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerComponent_StateDrivenReplication", "OnRep_LatestRecordedStateTreeTransitionResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.HandleBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::HandleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "HandleBeginOverlap");

	Params::FortActorComponent_StateDriven_HandleBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.HandleDamaged
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Momentum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::HandleDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "HandleDamaged");

	Params::FortActorComponent_StateDriven_HandleDamaged Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.Momentum = std::move(Momentum);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.HandleDied
// (Final, Native, Private, HasDefaults)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              FHitComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Momentum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::HandleDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "HandleDied");

	Params::FortActorComponent_StateDriven_HandleDied Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.HitLocation = std::move(HitLocation);
	Parms.FHitComponent = FHitComponent;
	Parms.BoneName = BoneName;
	Parms.Momentum = std::move(Momentum);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.HandleEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "HandleEndOverlap");

	Params::FortActorComponent_StateDriven_HandleEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.HandleInteraction
// (Final, Native, Private)
// Parameters:
// class ABuildingActor*                   SelfActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        InteractingPawn                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::HandleInteraction(class ABuildingActor* SelfActor, class AFortPawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "HandleInteraction");

	Params::FortActorComponent_StateDriven_HandleInteraction Parms{};

	Parms.SelfActor = SelfActor;
	Parms.InteractingPawn = InteractingPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.PopSlottedItem
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SlottedItemPopOffset                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortActorComponent_StateDriven::PopSlottedItem(const struct FVector& SlottedItemPopOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "PopSlottedItem");

	Params::FortActorComponent_StateDriven_PopSlottedItem Parms{};

	Parms.SlottedItemPopOffset = std::move(SlottedItemPopOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.GetSlottedItemDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFortActorComponent_StateDriven::GetSlottedItemDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "GetSlottedItemDisplayName");

	Params::FortActorComponent_StateDriven_GetSlottedItemDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function StateDrivenActorRuntime.FortActorComponent_StateDriven.GetSlottedItemEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFortItemEntry             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FFortItemEntry UFortActorComponent_StateDriven::GetSlottedItemEntry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortActorComponent_StateDriven", "GetSlottedItemEntry");

	Params::FortActorComponent_StateDriven_GetSlottedItemEntry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function StateDrivenActorRuntime.ObjectInstancedStateTreeComponent.OnRep_InstancedStateTreeId
// (Final, Native, Protected)

void UObjectInstancedStateTreeComponent::OnRep_InstancedStateTreeId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectInstancedStateTreeComponent", "OnRep_InstancedStateTreeId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.ObjectInstancedStateTreeComponent.SendStateTreeEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStateTreeEvent                  Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectInstancedStateTreeComponent::SendStateTreeEvent(class AActor* Instigator, const struct FStateTreeEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectInstancedStateTreeComponent", "SendStateTreeEvent");

	Params::ObjectInstancedStateTreeComponent_SendStateTreeEvent Parms{};

	Parms.Instigator = Instigator;
	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.ObjectInstancedStateTreeComponent.SetStartLogicAutomatically
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInStartLogicAutomatically                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectInstancedStateTreeComponent::SetStartLogicAutomatically(const bool bInStartLogicAutomatically)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectInstancedStateTreeComponent", "SetStartLogicAutomatically");

	Params::ObjectInstancedStateTreeComponent_SetStartLogicAutomatically Parms{};

	Parms.bInStartLogicAutomatically = bInStartLogicAutomatically;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.ObjectInstancedStateTreeComponent.GetContextualInstigatingActor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UObjectInstancedStateTreeComponent::GetContextualInstigatingActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectInstancedStateTreeComponent", "GetContextualInstigatingActor");

	Params::ObjectInstancedStateTreeComponent_GetContextualInstigatingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function StateDrivenActorRuntime.StateDrivenEventQuestObjectiveCompletedHelper.HandleQuestObjectiveCompleted
// (Final, Native, Public)
// Parameters:
// class UFortQuestObjectiveInfo*          ObjectiveInfo                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateDrivenEventQuestObjectiveCompletedHelper::HandleQuestObjectiveCompleted(class UFortQuestObjectiveInfo* ObjectiveInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateDrivenEventQuestObjectiveCompletedHelper", "HandleQuestObjectiveCompleted");

	Params::StateDrivenEventQuestObjectiveCompletedHelper_HandleQuestObjectiveCompleted Parms{};

	Parms.ObjectiveInfo = ObjectiveInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.WorldInstancedStateTreeComponent.MulticastSendStateTreeEvent
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRecordedStateTreeTransitionResult>RecordedTransitions                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldInstancedStateTreeComponent::MulticastSendStateTreeEvent(class AActor* Instigator, const TArray<struct FRecordedStateTreeTransitionResult>& RecordedTransitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldInstancedStateTreeComponent", "MulticastSendStateTreeEvent");

	Params::WorldInstancedStateTreeComponent_MulticastSendStateTreeEvent Parms{};

	Parms.Instigator = Instigator;
	Parms.RecordedTransitions = std::move(RecordedTransitions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.WorldInstancedStateTreeComponent.SendStateTreeEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStateTreeEvent                  Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldInstancedStateTreeComponent::SendStateTreeEvent(class AActor* Instigator, const struct FStateTreeEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldInstancedStateTreeComponent", "SendStateTreeEvent");

	Params::WorldInstancedStateTreeComponent_SendStateTreeEvent Parms{};

	Parms.Instigator = Instigator;
	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.WorldInstancedStateTreeComponent.SetStartLogicAutomatically
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInStartLogicAutomatically                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldInstancedStateTreeComponent::SetStartLogicAutomatically(const bool bInStartLogicAutomatically)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldInstancedStateTreeComponent", "SetStartLogicAutomatically");

	Params::WorldInstancedStateTreeComponent_SetStartLogicAutomatically Parms{};

	Parms.bInStartLogicAutomatically = bInStartLogicAutomatically;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function StateDrivenActorRuntime.WorldInstancedStateTreeComponent.GetStateTreeRunStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStateTreeRunStatus                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStateTreeRunStatus UWorldInstancedStateTreeComponent::GetStateTreeRunStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldInstancedStateTreeComponent", "GetStateTreeRunStatus");

	Params::WorldInstancedStateTreeComponent_GetStateTreeRunStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

