#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BeanstalkRuntime

#include "Basic.hpp"

#include "BeanstalkRuntime_classes.hpp"
#include "BeanstalkRuntime_parameters.hpp"


namespace SDK
{

// Function BeanstalkRuntime.BeanAudioDataAsset.GetSoundListsByCategory
// (Final, Native, Public, Const)
// Parameters:
// const TMap<struct FBeanAudioKey, struct FBeanAudioSet>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FBeanAudioKey, struct FBeanAudioSet> UBeanAudioDataAsset::GetSoundListsByCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanAudioDataAsset", "GetSoundListsByCategory");

	Params::BeanAudioDataAsset_GetSoundListsByCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.BP_OnBeanLocalInteractFailed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Interactable                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABeanCharacter::BP_OnBeanLocalInteractFailed(class AActor* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "BP_OnBeanLocalInteractFailed");

	Params::BeanCharacter_BP_OnBeanLocalInteractFailed Parms{};

	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BeanstalkRuntime.BeanCharacter.Client_OnTeleport
// (Net, NetReliable, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ABeanCharacter::Client_OnTeleport(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "Client_OnTeleport");

	Params::BeanCharacter_Client_OnTeleport Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.Client_TeleportSucceeded
// (Net, NetReliable, Native, Event, Protected, NetClient)

void ABeanCharacter::Client_TeleportSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "Client_TeleportSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.Debug_ServerActivateRagdoll
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABeanCharacter::Debug_ServerActivateRagdoll(const struct FVector& Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "Debug_ServerActivateRagdoll");

	Params::BeanCharacter_Debug_ServerActivateRagdoll Parms{};

	Parms.Force = std::move(Force);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.GetNetworkedPhysicsSettingsComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNetworkPhysicsSettingsComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNetworkPhysicsSettingsComponent* ABeanCharacter::GetNetworkedPhysicsSettingsComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetNetworkedPhysicsSettingsComponent");

	Params::BeanCharacter_GetNetworkedPhysicsSettingsComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.OnRep_EnableInventoryMode
// (Final, Native, Private)

void ABeanCharacter::OnRep_EnableInventoryMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "OnRep_EnableInventoryMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.PredictLaunch
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBeanLaunchPredictorInterface>SourceImpactPredictor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceOptionalSubobject                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABeanCharacter::PredictLaunch(TScriptInterface<class IBeanLaunchPredictorInterface> SourceImpactPredictor, class UObject* SourceOptionalSubobject, const struct FVector& LaunchVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "PredictLaunch");

	Params::BeanCharacter_PredictLaunch Parms{};

	Parms.SourceImpactPredictor = SourceImpactPredictor;
	Parms.SourceOptionalSubobject = SourceOptionalSubobject;
	Parms.LaunchVector = std::move(LaunchVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.ServerPlayEmote
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// class UAthenaDanceItemDefinition*       EmoteToPlay                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFortEmotePlayMode                      PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABeanCharacter::ServerPlayEmote(const class UAthenaDanceItemDefinition* EmoteToPlay, EFortEmotePlayMode PlayMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "ServerPlayEmote");

	Params::BeanCharacter_ServerPlayEmote Parms{};

	Parms.EmoteToPlay = EmoteToPlay;
	Parms.PlayMode = PlayMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.TriggerRagdoll
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsViaLaunch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABeanCharacter::TriggerRagdoll(const struct FVector& Force, bool bIsViaLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "TriggerRagdoll");

	Params::BeanCharacter_TriggerRagdoll Parms{};

	Parms.Force = std::move(Force);
	Parms.bIsViaLaunch = bIsViaLaunch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharacter.GetAllCosmeticMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> ABeanCharacter::GetAllCosmeticMaterials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetAllCosmeticMaterials");

	Params::BeanCharacter_GetAllCosmeticMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetBeanAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharAnimInstance*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharAnimInstance* ABeanCharacter::GetBeanAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetBeanAnimInstance");

	Params::BeanCharacter_GetBeanAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetBeanCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharMovementComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharMovementComponent* ABeanCharacter::GetBeanCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetBeanCharacterMovement");

	Params::BeanCharacter_GetBeanCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetBeingGrabbedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharBeingGrabbedComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharBeingGrabbedComponent* ABeanCharacter::GetBeingGrabbedComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetBeingGrabbedComponent");

	Params::BeanCharacter_GetBeingGrabbedComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetCollisionManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharCollisionManagerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharCollisionManagerComponent* ABeanCharacter::GetCollisionManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetCollisionManager");

	Params::BeanCharacter_GetCollisionManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetConfiguration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UBeanCharConfigObject*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UBeanCharConfigObject* ABeanCharacter::GetConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetConfiguration");

	Params::BeanCharacter_GetConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetGrabComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharGrabComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharGrabComponent* ABeanCharacter::GetGrabComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetGrabComponent");

	Params::BeanCharacter_GetGrabComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetJiggleMotionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanJiggleMotionComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanJiggleMotionComponent* ABeanCharacter::GetJiggleMotionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetJiggleMotionComponent");

	Params::BeanCharacter_GetJiggleMotionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetMantleComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharMantleComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharMantleComponent* ABeanCharacter::GetMantleComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetMantleComponent");

	Params::BeanCharacter_GetMantleComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetMeshScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABeanCharacter::GetMeshScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetMeshScale");

	Params::BeanCharacter_GetMeshScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.GetRagdollComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBeanCharRagdollComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBeanCharRagdollComponent* ABeanCharacter::GetRagdollComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "GetRagdollComponent");

	Params::BeanCharacter_GetRagdollComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharacter.IsBeingGrabbed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABeanCharacter::IsBeingGrabbed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharacter", "IsBeingGrabbed");

	Params::BeanCharacter_IsBeingGrabbed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharAnimInstance.GetConfig
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UBeanCharConfigObject*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UBeanCharConfigObject* UBeanCharAnimInstance::GetConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharAnimInstance", "GetConfig");

	Params::BeanCharAnimInstance_GetConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharAnimInstance.TryGetBeanCharacter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABeanCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABeanCharacter* UBeanCharAnimInstance::TryGetBeanCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharAnimInstance", "TryGetBeanCharacter");

	Params::BeanCharAnimInstance_TryGetBeanCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharBeingGrabbedComponent.GetGrabbeeDragForce
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DragDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeanCharBeingGrabbedComponent::GetGrabbeeDragForce(float DragDuration, const struct FVector& LocationOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharBeingGrabbedComponent", "GetGrabbeeDragForce");

	Params::BeanCharBeingGrabbedComponent_GetGrabbeeDragForce Parms{};

	Parms.DragDuration = DragDuration;
	Parms.LocationOffset = std::move(LocationOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharCameraConfig      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharCameraConfig UBeanCharConfigObject::GetCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetCamera");

	Params::BeanCharConfigObject_GetCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetCosmetics
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharCosmeticConfig    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharCosmeticConfig UBeanCharConfigObject::GetCosmetics() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetCosmetics");

	Params::BeanCharConfigObject_GetCosmetics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetDive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharDiveConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharDiveConfig UBeanCharConfigObject::GetDive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetDive");

	Params::BeanCharConfigObject_GetDive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetGetup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharGetupConfig       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharGetupConfig UBeanCharConfigObject::GetGetup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetGetup");

	Params::BeanCharConfigObject_GetGetup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetGetupRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharGetupRollConfig   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharGetupRollConfig UBeanCharConfigObject::GetGetupRoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetGetupRoll");

	Params::BeanCharConfigObject_GetGetupRoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetGrab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharGrabConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharGrabConfig UBeanCharConfigObject::GetGrab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetGrab");

	Params::BeanCharConfigObject_GetGrab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharHUDConfig         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharHUDConfig UBeanCharConfigObject::GetHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetHUD");

	Params::BeanCharConfigObject_GetHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetImpact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharImpactConfig      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharImpactConfig UBeanCharConfigObject::GetImpact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetImpact");

	Params::BeanCharConfigObject_GetImpact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharInteractionsConfigReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharInteractionsConfig UBeanCharConfigObject::GetInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetInteraction");

	Params::BeanCharConfigObject_GetInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetInventoryMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharInventoryModeConfigReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharInventoryModeConfig UBeanCharConfigObject::GetInventoryMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetInventoryMode");

	Params::BeanCharConfigObject_GetInventoryMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetJiggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharJiggleConfig      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharJiggleConfig UBeanCharConfigObject::GetJiggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetJiggle");

	Params::BeanCharConfigObject_GetJiggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetJostle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharJostleConfig      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharJostleConfig UBeanCharConfigObject::GetJostle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetJostle");

	Params::BeanCharConfigObject_GetJostle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharJumpConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharJumpConfig UBeanCharConfigObject::GetJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetJump");

	Params::BeanCharConfigObject_GetJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetMantle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharMantleConfig      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharMantleConfig UBeanCharConfigObject::GetMantle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetMantle");

	Params::BeanCharConfigObject_GetMantle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharMovementConfig    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharMovementConfig UBeanCharConfigObject::GetMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetMovement");

	Params::BeanCharConfigObject_GetMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetRagdoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharRagdollConfig     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBeanCharRagdollConfig UBeanCharConfigObject::GetRagdoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetRagdoll");

	Params::BeanCharConfigObject_GetRagdoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharRollConfig        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharRollConfig UBeanCharConfigObject::GetRoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetRoll");

	Params::BeanCharConfigObject_GetRoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetStagger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharStaggerConfig     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharStaggerConfig UBeanCharConfigObject::GetStagger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetStagger");

	Params::BeanCharConfigObject_GetStagger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetSwimming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharSwimmingConfig    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharSwimmingConfig UBeanCharConfigObject::GetSwimming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetSwimming");

	Params::BeanCharConfigObject_GetSwimming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetTouchControls
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharTouchControlsConfigReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharTouchControlsConfig UBeanCharConfigObject::GetTouchControls() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetTouchControls");

	Params::BeanCharConfigObject_GetTouchControls Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharConfigObject.GetZipline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBeanCharZiplineConfig     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FBeanCharZiplineConfig UBeanCharConfigObject::GetZipline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharConfigObject", "GetZipline");

	Params::BeanCharConfigObject_GetZipline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharGrabComponent.GetGrabberDragForce
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   DragDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeanCharGrabComponent::GetGrabberDragForce(float DragDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharGrabComponent", "GetGrabberDragForce");

	Params::BeanCharGrabComponent_GetGrabberDragForce Parms{};

	Parms.DragDuration = DragDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharGrabComponent.HandleOnPawnJumped
// (Final, Native, Private)

void UBeanCharGrabComponent::HandleOnPawnJumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharGrabComponent", "HandleOnPawnJumped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharGrabComponent.OnRep_GrabTarget
// (Final, Native, Private)

void UBeanCharGrabComponent::OnRep_GrabTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharGrabComponent", "OnRep_GrabTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharGrabComponent.OnRep_ServerLatestHoldStartTime
// (Final, Native, Private)

void UBeanCharGrabComponent::OnRep_ServerLatestHoldStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharGrabComponent", "OnRep_ServerLatestHoldStartTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.ApplyKnockbackImpulse
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharMovementComponent::ApplyKnockbackImpulse(const struct FVector& Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "ApplyKnockbackImpulse");

	Params::BeanCharMovementComponent_ApplyKnockbackImpulse Parms{};

	Parms.Force = std::move(Force);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.Server_SetDebugForceCorrection
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// EBeanDebugForceCorrectionMode           Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharMovementComponent::Server_SetDebugForceCorrection(EBeanDebugForceCorrectionMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "Server_SetDebugForceCorrection");

	Params::BeanCharMovementComponent_Server_SetDebugForceCorrection Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.ServerRequestPredictLaunch
// (Net, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceOptionalSubobject                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVector                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementTimestamp                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharMovementComponent::ServerRequestPredictLaunch(class UObject* SourceObject, class UObject* SourceOptionalSubobject, const struct FVector& LaunchVector, float MovementTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "ServerRequestPredictLaunch");

	Params::BeanCharMovementComponent_ServerRequestPredictLaunch Parms{};

	Parms.SourceObject = SourceObject;
	Parms.SourceOptionalSubobject = SourceOptionalSubobject;
	Parms.LaunchVector = std::move(LaunchVector);
	Parms.MovementTimestamp = MovementTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.ServerSuggestImpartedMovementBaseVelocity
// (Final, Net, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FVector                          ImpartedVelocity                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharMovementComponent::ServerSuggestImpartedMovementBaseVelocity(const struct FVector& ImpartedVelocity, float Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "ServerSuggestImpartedMovementBaseVelocity");

	Params::BeanCharMovementComponent_ServerSuggestImpartedMovementBaseVelocity Parms{};

	Parms.ImpartedVelocity = std::move(ImpartedVelocity);
	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.SetTurn180State
// (Final, Native, Public)
// Parameters:
// EBeanCharTurn180State                   NewTurnState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharMovementComponent::SetTurn180State(EBeanCharTurn180State NewTurnState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "SetTurn180State");

	Params::BeanCharMovementComponent_SetTurn180State Parms{};

	Parms.NewTurnState = NewTurnState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.GetBeanCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABeanCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABeanCharacter* UBeanCharMovementComponent::GetBeanCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "GetBeanCharacter");

	Params::BeanCharMovementComponent_GetBeanCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharMovementComponent.GetTurn180State
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBeanCharTurn180State                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBeanCharTurn180State UBeanCharMovementComponent::GetTurn180State() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharMovementComponent", "GetTurn180State");

	Params::BeanCharMovementComponent_GetTurn180State Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.ApplyImpulse
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Force                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLaunch                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharRagdollComponent::ApplyImpulse(const struct FVector& Force, bool bIsLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "ApplyImpulse");

	Params::BeanCharRagdollComponent_ApplyImpulse Parms{};

	Parms.Force = std::move(Force);
	Parms.bIsLaunch = bIsLaunch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.CleanupRagdollForAbruptExit
// (Final, Native, Public)

void UBeanCharRagdollComponent::CleanupRagdollForAbruptExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "CleanupRagdollForAbruptExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.Client_CleanupRagdollForAbruptExit
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UBeanCharRagdollComponent::Client_CleanupRagdollForAbruptExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "Client_CleanupRagdollForAbruptExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.Client_SignalRagdollExit
// (Net, NetReliable, Native, Event, Protected, HasDefaults, NetClient)
// Parameters:
// struct FVector                          EndLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            EndRotation                                            (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndVelocity                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharRagdollComponent::Client_SignalRagdollExit(const struct FVector& EndLocation, const struct FQuat& EndRotation, const struct FVector& EndVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "Client_SignalRagdollExit");

	Params::BeanCharRagdollComponent_Client_SignalRagdollExit Parms{};

	Parms.EndLocation = std::move(EndLocation);
	Parms.EndRotation = std::move(EndRotation);
	Parms.EndVelocity = std::move(EndVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.OnRagdollRootPrimitiveHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBeanCharRagdollComponent::OnRagdollRootPrimitiveHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "OnRagdollRootPrimitiveHit");

	Params::BeanCharRagdollComponent_OnRagdollRootPrimitiveHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.RequestRagdollExit
// (Final, Native, Public)

void UBeanCharRagdollComponent::RequestRagdollExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "RequestRagdollExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.Server_SignalClientExitedRagdoll
// (Net, NetReliable, Native, Event, Protected, NetServer)

void UBeanCharRagdollComponent::Server_SignalClientExitedRagdoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "Server_SignalClientExitedRagdoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.ServerRPCRagdollControlInput
// (Net, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FVector                          InputVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharRagdollComponent::ServerRPCRagdollControlInput(const struct FVector& InputVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "ServerRPCRagdollControlInput");

	Params::BeanCharRagdollComponent_ServerRPCRagdollControlInput Parms{};

	Parms.InputVector = std::move(InputVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharRagdollComponent.SetRagdollEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bShouldEnable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharRagdollComponent::SetRagdollEnabled(bool bShouldEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharRagdollComponent", "SetRagdollEnabled");

	Params::BeanCharRagdollComponent_SetRagdollEnabled Parms{};

	Parms.bShouldEnable = bShouldEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.Client_ForceSetState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// EBeanCharStateID                        StateUP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeanCharStateID                        StateLW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   SyncID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetPredictionData                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharStateMachine::Client_ForceSetState(EBeanCharStateID StateUP, EBeanCharStateID StateLW, uint8 SyncID, bool bResetPredictionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "Client_ForceSetState");

	Params::BeanCharStateMachine_Client_ForceSetState Parms{};

	Parms.StateUP = StateUP;
	Parms.StateLW = StateLW;
	Parms.SyncID = SyncID;
	Parms.bResetPredictionData = bResetPredictionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.ClientRPC_RequestClientChangesState
// (Final, Net, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// EBeanCharStateID                        StateID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBeanCharStateMachine::ClientRPC_RequestClientChangesState(EBeanCharStateID StateID, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "ClientRPC_RequestClientChangesState");

	Params::BeanCharStateMachine_ClientRPC_RequestClientChangesState Parms{};

	Parms.StateID = StateID;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.Debug_RequestClientChangesState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBeanCharStateID                        StateID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharStateMachine::Debug_RequestClientChangesState(EBeanCharStateID StateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "Debug_RequestClientChangesState");

	Params::BeanCharStateMachine_Debug_RequestClientChangesState Parms{};

	Parms.StateID = StateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.OnRep_AutonomousProxyStateData
// (Final, Native, Private)

void UBeanCharStateMachine::OnRep_AutonomousProxyStateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "OnRep_AutonomousProxyStateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.OnRep_SimulatedProxyStateData
// (Final, Native, Private)

void UBeanCharStateMachine::OnRep_SimulatedProxyStateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "OnRep_SimulatedProxyStateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.ServerRPC_RequestClientChangeStateResponse
// (Final, Net, Native, Event, Private, NetServer)
// Parameters:
// EBeanCharStateID                        StateID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharStateMachine::ServerRPC_RequestClientChangeStateResponse(EBeanCharStateID StateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "ServerRPC_RequestClientChangeStateResponse");

	Params::BeanCharStateMachine_ServerRPC_RequestClientChangeStateResponse Parms{};

	Parms.StateID = StateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCharStateMachine.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBeanCharStateLayerID                   LayerID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBeanCharStateBase>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UBeanCharStateBase> UBeanCharStateMachine::GetState(EBeanCharStateLayerID LayerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "GetState");

	Params::BeanCharStateMachine_GetState Parms{};

	Parms.LayerID = LayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharStateMachine.GetStateActiveDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBeanCharStateID                        StateID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBeanCharStateMachine::GetStateActiveDuration(EBeanCharStateID StateID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "GetStateActiveDuration");

	Params::BeanCharStateMachine_GetStateActiveDuration Parms{};

	Parms.StateID = StateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharStateMachine.GetStateID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EBeanCharStateLayerID                   LayerID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeanCharStateID                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBeanCharStateID UBeanCharStateMachine::GetStateID(EBeanCharStateLayerID LayerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharStateMachine", "GetStateID");

	Params::BeanCharStateMachine_GetStateID Parms{};

	Parms.LayerID = LayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanCharState_Emote.OnEmoteFinishedCallback
// (Final, Native, Private)
// Parameters:
// int32                                   EmoteIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasInterruption                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCharState_Emote::OnEmoteFinishedCallback(int32 EmoteIndex, bool bWasInterruption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCharState_Emote", "OnEmoteFinishedCallback");

	Params::BeanCharState_Emote_OnEmoteFinishedCallback Parms{};

	Parms.EmoteIndex = EmoteIndex;
	Parms.bWasInterruption = bWasInterruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanAllowItemInteractionByTag
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanAllowItemInteractionByTag(const class FString& TagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanAllowItemInteractionByTag");

	Params::BeanCheatManager_BeanAllowItemInteractionByTag Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanEnableInventoryMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanEnableInventoryMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanEnableInventoryMode");

	Params::BeanCheatManager_BeanEnableInventoryMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanToggleAbilityRestrictions
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bApplyRestrictions                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanToggleAbilityRestrictions(bool bApplyRestrictions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanToggleAbilityRestrictions");

	Params::BeanCheatManager_BeanToggleAbilityRestrictions Parms{};

	Parms.bApplyRestrictions = bApplyRestrictions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanTogglePickupRestrictions
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bApplyRestrictions                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanTogglePickupRestrictions(bool bApplyRestrictions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanTogglePickupRestrictions");

	Params::BeanCheatManager_BeanTogglePickupRestrictions Parms{};

	Parms.bApplyRestrictions = bApplyRestrictions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanUnlockBuildMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bUnlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanUnlockBuildMode(bool bUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanUnlockBuildMode");

	Params::BeanCheatManager_BeanUnlockBuildMode Parms{};

	Parms.bUnlock = bUnlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanUnlockPlayerActionByTag
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanUnlockPlayerActionByTag(const class FString& TagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanUnlockPlayerActionByTag");

	Params::BeanCheatManager_BeanUnlockPlayerActionByTag Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.RespawnAsDefaultPawn
// (Final, Exec, Native, Public)

void UBeanCheatManager::RespawnAsDefaultPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "RespawnAsDefaultPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.SwitchBackFromBeanPawn
// (Final, Exec, Native, Public)

void UBeanCheatManager::SwitchBackFromBeanPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "SwitchBackFromBeanPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.SwitchToBeanPawn
// (Final, Exec, Native, Public)

void UBeanCheatManager::SwitchToBeanPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "SwitchToBeanPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanDisallowItemInteractionByTag
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanDisallowItemInteractionByTag(const class FString& TagString) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanDisallowItemInteractionByTag");

	Params::BeanCheatManager_BeanDisallowItemInteractionByTag Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanEnableBeanInEditMode
// (Final, Exec, Native, Public, Const)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanEnableBeanInEditMode(bool bEnabled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanEnableBeanInEditMode");

	Params::BeanCheatManager_BeanEnableBeanInEditMode Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanEnableGetupSpeedModifier
// (Final, Exec, Native, Public, Const)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanEnableGetupSpeedModifier(bool bEnabled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanEnableGetupSpeedModifier");

	Params::BeanCheatManager_BeanEnableGetupSpeedModifier Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanRelockPlayerActionByTag
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           TagString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanRelockPlayerActionByTag(const class FString& TagString) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanRelockPlayerActionByTag");

	Params::BeanCheatManager_BeanRelockPlayerActionByTag Parms{};

	Parms.TagString = std::move(TagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanCheatManager.BeanSetGlobalRagdollThreshold
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanCheatManager::BeanSetGlobalRagdollThreshold(float Threshold) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanCheatManager", "BeanSetGlobalRagdollThreshold");

	Params::BeanCheatManager_BeanSetGlobalRagdollThreshold Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanLaunchPredictorInterface.ValidateLaunch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FBeanPredictedLaunch             PredictedLaunch                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IBeanLaunchPredictorInterface::ValidateLaunch(const struct FBeanPredictedLaunch& PredictedLaunch) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeanLaunchPredictorInterface", "ValidateLaunch");

	Params::BeanLaunchPredictorInterface_ValidateLaunch Parms{};

	Parms.PredictedLaunch = std::move(PredictedLaunch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnBeanStateChanged_AddToHistory
// (Final, Native, Public)
// Parameters:
// EBeanCharStateID                        StateId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeanCharStateLayerID                   LayerId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReplaying                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnBeanStateChanged_AddToHistory(EBeanCharStateID StateId, EBeanCharStateLayerID LayerId, bool bIsReplaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnBeanStateChanged_AddToHistory");

	Params::FortAutomationRpcManager_Beanstalk_OnBeanStateChanged_AddToHistory Parms{};

	Parms.StateId = StateId;
	Parms.LayerId = LayerId;
	Parms.bIsReplaying = bIsReplaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnBeanStateChanged_BroadcastMessage
// (Final, Native, Public)
// Parameters:
// EBeanCharStateID                        StateId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeanCharStateLayerID                   LayerId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReplaying                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnBeanStateChanged_BroadcastMessage(EBeanCharStateID StateId, EBeanCharStateLayerID LayerId, bool bIsReplaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnBeanStateChanged_BroadcastMessage");

	Params::FortAutomationRpcManager_Beanstalk_OnBeanStateChanged_BroadcastMessage Parms{};

	Parms.StateId = StateId;
	Parms.LayerId = LayerId;
	Parms.bIsReplaying = bIsReplaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnBeanStateChanged_Grounded_ResetDive
// (Final, Native, Public)
// Parameters:
// EBeanCharStateID                        StateId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBeanCharStateLayerID                   LayerId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsReplaying                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnBeanStateChanged_Grounded_ResetDive(EBeanCharStateID StateId, EBeanCharStateLayerID LayerId, bool bIsReplaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnBeanStateChanged_Grounded_ResetDive");

	Params::FortAutomationRpcManager_Beanstalk_OnBeanStateChanged_Grounded_ResetDive Parms{};

	Parms.StateId = StateId;
	Parms.LayerId = LayerId;
	Parms.bIsReplaying = bIsReplaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnCharacterOverlap_BroadcastMessage
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnCharacterOverlap_BroadcastMessage(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnCharacterOverlap_BroadcastMessage");

	Params::FortAutomationRpcManager_Beanstalk_OnCharacterOverlap_BroadcastMessage Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnCharacterOverlap_Dive
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnCharacterOverlap_Dive(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnCharacterOverlap_Dive");

	Params::FortAutomationRpcManager_Beanstalk_OnCharacterOverlap_Dive Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.FortAutomationRpcManager_Beanstalk.OnCharacterOverlap_Jump
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAutomationRpcManager_Beanstalk::OnCharacterOverlap_Jump(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAutomationRpcManager_Beanstalk", "OnCharacterOverlap_Jump");

	Params::FortAutomationRpcManager_Beanstalk_OnCharacterOverlap_Jump Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanstalkFunctionLibrary.CanPawnSwitchToBeanNow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AFortPlayerPawn*                  PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBeanstalkFunctionLibrary::CanPawnSwitchToBeanNow(const class AFortPlayerPawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BeanstalkFunctionLibrary", "CanPawnSwitchToBeanNow");

	Params::BeanstalkFunctionLibrary_CanPawnSwitchToBeanNow Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanstalkFunctionLibrary.CanPlayerSwitchToBeanNow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBeanstalkFunctionLibrary::CanPlayerSwitchToBeanNow(const class AFortPlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BeanstalkFunctionLibrary", "CanPlayerSwitchToBeanNow");

	Params::BeanstalkFunctionLibrary_CanPlayerSwitchToBeanNow Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function BeanstalkRuntime.BeanstalkFunctionLibrary.SwitchBackFromBeanPawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeanstalkFunctionLibrary::SwitchBackFromBeanPawn(class AFortPlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BeanstalkFunctionLibrary", "SwitchBackFromBeanPawn");

	Params::BeanstalkFunctionLibrary_SwitchBackFromBeanPawn Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function BeanstalkRuntime.BeanstalkFunctionLibrary.SwitchToBeanPawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBeanstalkFunctionLibrary::SwitchToBeanPawn(class AFortPlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BeanstalkFunctionLibrary", "SwitchToBeanPawn");

	Params::BeanstalkFunctionLibrary_SwitchToBeanPawn Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

