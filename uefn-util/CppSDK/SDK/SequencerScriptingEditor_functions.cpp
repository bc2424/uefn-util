#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SequencerScriptingEditor

#include "Basic.hpp"

#include "SequencerScriptingEditor_classes.hpp"
#include "SequencerScriptingEditor_parameters.hpp"


namespace SDK
{

// Function SequencerScriptingEditor.SequencerCurveEditorObject.ApplyFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveEditorFilterBase*           Filter                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::ApplyFilter(class UCurveEditorFilterBase* Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "ApplyFilter");

	Params::SequencerCurveEditorObject_ApplyFilter Parms{};

	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.CloseCurveEditor
// (Final, Native, Public, BlueprintCallable)

void USequencerCurveEditorObject::CloseCurveEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "CloseCurveEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.DeleteColorForChannels
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Identifier                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::DeleteColorForChannels(class UClass* Class_0, class FString* Identifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "DeleteColorForChannels");

	Params::SequencerCurveEditorObject_DeleteColorForChannels Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Identifier != nullptr)
		*Identifier = std::move(Parms.Identifier);
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.EmptySelection
// (Final, Native, Public, BlueprintCallable)

void USequencerCurveEditorObject::EmptySelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "EmptySelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.GetChannelsWithSelectedKeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSequencerChannelProxy>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FSequencerChannelProxy> USequencerCurveEditorObject::GetChannelsWithSelectedKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "GetChannelsWithSelectedKeys");

	Params::SequencerCurveEditorObject_GetChannelsWithSelectedKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.GetCustomColorForChannel
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Identifier                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USequencerCurveEditorObject::GetCustomColorForChannel(class UClass* Class_0, const class FString& Identifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "GetCustomColorForChannel");

	Params::SequencerCurveEditorObject_GetCustomColorForChannel Parms{};

	Parms.Class_0 = Class_0;
	Parms.Identifier = std::move(Identifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.GetSelectedKeys
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSequencerChannelProxy           ChannelProxy                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> USequencerCurveEditorObject::GetSelectedKeys(const struct FSequencerChannelProxy& ChannelProxy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "GetSelectedKeys");

	Params::SequencerCurveEditorObject_GetSelectedKeys Parms{};

	Parms.ChannelProxy = std::move(ChannelProxy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.HasCustomColorForChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Identifier                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerCurveEditorObject::HasCustomColorForChannel(class UClass* Class_0, const class FString& Identifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "HasCustomColorForChannel");

	Params::SequencerCurveEditorObject_HasCustomColorForChannel Parms{};

	Parms.Class_0 = Class_0;
	Parms.Identifier = std::move(Identifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.IsCurveEditorOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerCurveEditorObject::IsCurveEditorOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "IsCurveEditorOpen");

	Params::SequencerCurveEditorObject_IsCurveEditorOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.IsCurveShown
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerChannelProxy           Channel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerCurveEditorObject::IsCurveShown(const struct FSequencerChannelProxy& Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "IsCurveShown");

	Params::SequencerCurveEditorObject_IsCurveShown Parms{};

	Parms.Channel = std::move(Channel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.OpenCurveEditor
// (Final, Native, Public, BlueprintCallable)

void USequencerCurveEditorObject::OpenCurveEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "OpenCurveEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.SelectKeys
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerChannelProxy           Channel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<int32>                           Indices                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::SelectKeys(const struct FSequencerChannelProxy& Channel, const TArray<int32>& Indices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "SelectKeys");

	Params::SequencerCurveEditorObject_SelectKeys Parms{};

	Parms.Channel = std::move(Channel);
	Parms.Indices = std::move(Indices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.SetCustomColorForChannel
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Identifier                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     NewColor                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::SetCustomColorForChannel(class UClass* Class_0, const class FString& Identifier, const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "SetCustomColorForChannel");

	Params::SequencerCurveEditorObject_SetCustomColorForChannel Parms{};

	Parms.Class_0 = Class_0;
	Parms.Identifier = std::move(Identifier);
	Parms.NewColor = std::move(NewColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.SetCustomColorForChannels
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Identifiers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             NewColors                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::SetCustomColorForChannels(class UClass* Class_0, const TArray<class FString>& Identifiers, const TArray<struct FLinearColor>& NewColors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "SetCustomColorForChannels");

	Params::SequencerCurveEditorObject_SetCustomColorForChannels Parms{};

	Parms.Class_0 = Class_0;
	Parms.Identifiers = std::move(Identifiers);
	Parms.NewColors = std::move(NewColors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.SetRandomColorForChannels
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Identifiers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::SetRandomColorForChannels(class UClass* Class_0, const TArray<class FString>& Identifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "SetRandomColorForChannels");

	Params::SequencerCurveEditorObject_SetRandomColorForChannels Parms{};

	Parms.Class_0 = Class_0;
	Parms.Identifiers = std::move(Identifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerCurveEditorObject.ShowCurve
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerChannelProxy           Channel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bShowCurve                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerCurveEditorObject::ShowCurve(const struct FSequencerChannelProxy& Channel, bool bShowCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerCurveEditorObject", "ShowCurve");

	Params::SequencerCurveEditorObject_ShowCurve Parms{};

	Parms.Channel = std::move(Channel);
	Parms.bShowCurve = bShowCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.CancelMovieRender
// (Final, Native, Static, Public, BlueprintCallable)

void USequencerToolsFunctionLibrary::CancelMovieRender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "CancelMovieRender");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ClearLinkedAnimSequences
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerToolsFunctionLibrary::ClearLinkedAnimSequences(class ULevelSequence* InLevelSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ClearLinkedAnimSequences");

	Params::SequencerToolsFunctionLibrary_ClearLinkedAnimSequences Parms{};

	Parms.InLevelSequence = InLevelSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.CreateEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMovieSceneEventSectionBase*      InSection                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequencerQuickBindingResult     InEndpoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   InPayload                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMovieSceneEvent                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMovieSceneEvent USequencerToolsFunctionLibrary::CreateEvent(class UMovieSceneSequence* InSequence, class UMovieSceneEventSectionBase* InSection, const struct FSequencerQuickBindingResult& InEndpoint, const TArray<class FString>& InPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "CreateEvent");

	Params::SequencerToolsFunctionLibrary_CreateEvent Parms{};

	Parms.InSequence = InSequence;
	Parms.InSection = InSection;
	Parms.InEndpoint = std::move(InEndpoint);
	Parms.InPayload = std::move(InPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.CreateQuickBinding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InFunctionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallInEditor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequencerQuickBindingResult     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSequencerQuickBindingResult USequencerToolsFunctionLibrary::CreateQuickBinding(class UMovieSceneSequence* InSequence, class UObject* InObject, const class FString& InFunctionName, bool bCallInEditor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "CreateQuickBinding");

	Params::SequencerToolsFunctionLibrary_CreateQuickBinding Parms{};

	Parms.InSequence = InSequence;
	Parms.InObject = InObject;
	Parms.InFunctionName = std::move(InFunctionName);
	Parms.bCallInEditor = bCallInEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ExportAnimSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSeqExportOption*             ExportOption                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneBindingProxy          Binding                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateLink                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::ExportAnimSequence(class UWorld* World, class ULevelSequence* Sequence, class UAnimSequence* AnimSequence, class UAnimSeqExportOption* ExportOption, const struct FMovieSceneBindingProxy& Binding, bool bCreateLink)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ExportAnimSequence");

	Params::SequencerToolsFunctionLibrary_ExportAnimSequence Parms{};

	Parms.World = World;
	Parms.Sequence = Sequence;
	Parms.AnimSequence = AnimSequence;
	Parms.ExportOption = ExportOption;
	Parms.Binding = std::move(Binding);
	Parms.bCreateLink = bCreateLink;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ExportFBXFromControlRig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActorWithControlRigTrack                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMovieSceneUserExportFBXControlRigSettings*ExportFBXControlRigSettings                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::ExportFBXFromControlRig(class ULevelSequence* Sequence, const class FString& ActorWithControlRigTrack, const class UMovieSceneUserExportFBXControlRigSettings* ExportFBXControlRigSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ExportFBXFromControlRig");

	Params::SequencerToolsFunctionLibrary_ExportFBXFromControlRig Parms{};

	Parms.Sequence = Sequence;
	Parms.ActorWithControlRigTrack = std::move(ActorWithControlRigTrack);
	Parms.ExportFBXControlRigSettings = ExportFBXControlRigSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ExportLevelSequenceFBX
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerExportFBXParams        InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::ExportLevelSequenceFBX(const struct FSequencerExportFBXParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ExportLevelSequenceFBX");

	Params::SequencerToolsFunctionLibrary_ExportLevelSequenceFBX Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.GetAnimSequenceLinkFromLevelSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequenceAnimSequenceLink*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequenceAnimSequenceLink* USequencerToolsFunctionLibrary::GetAnimSequenceLinkFromLevelSequence(class ULevelSequence* InLevelSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "GetAnimSequenceLinkFromLevelSequence");

	Params::SequencerToolsFunctionLibrary_GetAnimSequenceLinkFromLevelSequence Parms{};

	Parms.InLevelSequence = InLevelSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.GetBoundObjects
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMovieSceneBindingProxy>  InBindings                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSequencerScriptingRange         InRange                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSequencerBoundObjects>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSequencerBoundObjects> USequencerToolsFunctionLibrary::GetBoundObjects(class UWorld* InWorld, class ULevelSequence* InSequence, const TArray<struct FMovieSceneBindingProxy>& InBindings, const struct FSequencerScriptingRange& InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "GetBoundObjects");

	Params::SequencerToolsFunctionLibrary_GetBoundObjects Parms{};

	Parms.InWorld = InWorld;
	Parms.InSequence = InSequence;
	Parms.InBindings = std::move(InBindings);
	Parms.InRange = std::move(InRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.GetLevelSequenceLinkFromAnimSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InAnimSequence                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceLevelSequenceLink*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceLevelSequenceLink* USequencerToolsFunctionLibrary::GetLevelSequenceLinkFromAnimSequence(class UAnimSequence* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "GetLevelSequenceLinkFromAnimSequence");

	Params::SequencerToolsFunctionLibrary_GetLevelSequenceLinkFromAnimSequence Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.GetObjectBindings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  InObject                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSequencerScriptingRange         InRange                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSequencerBoundObjects>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSequencerBoundObjects> USequencerToolsFunctionLibrary::GetObjectBindings(class UWorld* InWorld, class ULevelSequence* InSequence, const TArray<class UObject*>& InObject, const struct FSequencerScriptingRange& InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "GetObjectBindings");

	Params::SequencerToolsFunctionLibrary_GetObjectBindings Parms{};

	Parms.InWorld = InWorld;
	Parms.InSequence = InSequence;
	Parms.InObject = std::move(InObject);
	Parms.InRange = std::move(InRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ImportFBXToControlRig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActorWithControlRigTrack                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   SelectedControlRigNames                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UMovieSceneUserImportFBXControlRigSettings*ImportFBXControlRigSettings                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ImportFilename                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::ImportFBXToControlRig(class UWorld* World, class ULevelSequence* InSequence, const class FString& ActorWithControlRigTrack, const TArray<class FString>& SelectedControlRigNames, class UMovieSceneUserImportFBXControlRigSettings* ImportFBXControlRigSettings, const class FString& ImportFilename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ImportFBXToControlRig");

	Params::SequencerToolsFunctionLibrary_ImportFBXToControlRig Parms{};

	Parms.World = World;
	Parms.InSequence = InSequence;
	Parms.ActorWithControlRigTrack = std::move(ActorWithControlRigTrack);
	Parms.SelectedControlRigNames = std::move(SelectedControlRigNames);
	Parms.ImportFBXControlRigSettings = ImportFBXControlRigSettings;
	Parms.ImportFilename = std::move(ImportFilename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.ImportLevelSequenceFBX
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InSequence                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMovieSceneBindingProxy>  InBindings                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UMovieSceneUserImportFBXSettings* InImportFBXSettings                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InImportFilename                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::ImportLevelSequenceFBX(class UWorld* InWorld, class ULevelSequence* InSequence, const TArray<struct FMovieSceneBindingProxy>& InBindings, class UMovieSceneUserImportFBXSettings* InImportFBXSettings, const class FString& InImportFilename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "ImportLevelSequenceFBX");

	Params::SequencerToolsFunctionLibrary_ImportLevelSequenceFBX Parms{};

	Parms.InWorld = InWorld;
	Parms.InSequence = InSequence;
	Parms.InBindings = std::move(InBindings);
	Parms.InImportFBXSettings = InImportFBXSettings;
	Parms.InImportFilename = std::move(InImportFilename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.IsEventEndpointValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerQuickBindingResult     InEndpoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::IsEventEndpointValid(const struct FSequencerQuickBindingResult& InEndpoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "IsEventEndpointValid");

	Params::SequencerToolsFunctionLibrary_IsEventEndpointValid Parms{};

	Parms.InEndpoint = std::move(InEndpoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.IsRenderingMovie
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::IsRenderingMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "IsRenderingMovie");

	Params::SequencerToolsFunctionLibrary_IsRenderingMovie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.LinkAnimSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   Sequence                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSeqExportOption*             ExportOptions                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneBindingProxy          Binding                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::LinkAnimSequence(class ULevelSequence* Sequence, class UAnimSequence* AnimSequence, const class UAnimSeqExportOption* ExportOptions, const struct FMovieSceneBindingProxy& Binding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "LinkAnimSequence");

	Params::SequencerToolsFunctionLibrary_LinkAnimSequence Parms{};

	Parms.Sequence = Sequence;
	Parms.AnimSequence = AnimSequence;
	Parms.ExportOptions = ExportOptions;
	Parms.Binding = std::move(Binding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SequencerScriptingEditor.SequencerToolsFunctionLibrary.RenderMovie
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMovieSceneCapture*               InCaptureSettings                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool bSuccess)>          OnFinishedCallback                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USequencerToolsFunctionLibrary::RenderMovie(class UMovieSceneCapture* InCaptureSettings, TDelegate<void(bool bSuccess)> OnFinishedCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SequencerToolsFunctionLibrary", "RenderMovie");

	Params::SequencerToolsFunctionLibrary_RenderMovie Parms{};

	Parms.InCaptureSettings = InCaptureSettings;
	Parms.OnFinishedCallback = OnFinishedCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

