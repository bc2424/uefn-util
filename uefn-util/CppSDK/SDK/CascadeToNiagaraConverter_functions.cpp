#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CascadeToNiagaraConverter

#include "Basic.hpp"

#include "CascadeToNiagaraConverter_classes.hpp"
#include "CascadeToNiagaraConverter_parameters.hpp"


namespace SDK
{

// Function CascadeToNiagaraConverter.NiagaraSystemConversionContext.AddEmptyEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewEmitterNameString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraEmitterConversionContext* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraEmitterConversionContext* UNiagaraSystemConversionContext::AddEmptyEmitter(const class FString& NewEmitterNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraSystemConversionContext", "AddEmptyEmitter");

	Params::NiagaraSystemConversionContext_AddEmptyEmitter Parms{};

	Parms.NewEmitterNameString = std::move(NewEmitterNameString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraSystemConversionContext.Cleanup
// (Final, Native, Public, BlueprintCallable)

void UNiagaraSystemConversionContext::Cleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraSystemConversionContext", "Cleanup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraSystemConversionContext.Finalize
// (Final, Native, Public, BlueprintCallable)

void UNiagaraSystemConversionContext::Finalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraSystemConversionContext", "Finalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.AddEventHandler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNiagaraEventHandlerAddAction    EventScriptPropertiesBP                                (Parm, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::AddEventHandler(const struct FNiagaraEventHandlerAddAction& EventScriptPropertiesBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "AddEventHandler");

	Params::NiagaraEmitterConversionContext_AddEventHandler Parms{};

	Parms.EventScriptPropertiesBP = std::move(EventScriptPropertiesBP);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.AddModuleEventScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptNameString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ScriptConversionContext                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNiagaraEventHandlerAddAction    EventScriptProps                                       (Parm, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::AddModuleEventScript(const class FString& ScriptNameString, class UNiagaraScriptConversionContext* ScriptConversionContext, const struct FNiagaraEventHandlerAddAction& EventScriptProps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "AddModuleEventScript");

	Params::NiagaraEmitterConversionContext_AddModuleEventScript Parms{};

	Parms.ScriptNameString = std::move(ScriptNameString);
	Parms.ScriptConversionContext = ScriptConversionContext;
	Parms.EventScriptProps = std::move(EventScriptProps);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.AddModuleScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptNameString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ScriptConversionContext                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScriptExecutionCategory                ModuleScriptExecutionCategory                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::AddModuleScript(const class FString& ScriptNameString, class UNiagaraScriptConversionContext* ScriptConversionContext, EScriptExecutionCategory ModuleScriptExecutionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "AddModuleScript");

	Params::NiagaraEmitterConversionContext_AddModuleScript Parms{};

	Parms.ScriptNameString = std::move(ScriptNameString);
	Parms.ScriptConversionContext = ScriptConversionContext;
	Parms.ModuleScriptExecutionCategory = ModuleScriptExecutionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.AddRenderer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RendererNameString                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraRendererProperties*       NewRendererProperties                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::AddRenderer(const class FString& RendererNameString, class UNiagaraRendererProperties* NewRendererProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "AddRenderer");

	Params::NiagaraEmitterConversionContext_AddRenderer Parms{};

	Parms.RendererNameString = std::move(RendererNameString);
	Parms.NewRendererProperties = NewRendererProperties;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.Cleanup
// (Final, Native, Public, BlueprintCallable)

void UNiagaraEmitterConversionContext::Cleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "Cleanup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.Finalize
// (Final, Native, Public, BlueprintCallable)

void UNiagaraEmitterConversionContext::Finalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "Finalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.FindModuleScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptNameString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContext* UNiagaraEmitterConversionContext::FindModuleScript(const class FString& ScriptNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "FindModuleScript");

	Params::NiagaraEmitterConversionContext_FindModuleScript Parms{};

	Parms.ScriptNameString = std::move(ScriptNameString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.FindOrAddModuleEventScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptNameString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCreateScriptContextArgs         CreateScriptContextArgs                                (Parm, NativeAccessSpecifierPublic)
// struct FNiagaraEventHandlerAddAction    EventScriptProps                                       (Parm, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContext* UNiagaraEmitterConversionContext::FindOrAddModuleEventScript(const class FString& ScriptNameString, const struct FCreateScriptContextArgs& CreateScriptContextArgs, const struct FNiagaraEventHandlerAddAction& EventScriptProps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "FindOrAddModuleEventScript");

	Params::NiagaraEmitterConversionContext_FindOrAddModuleEventScript Parms{};

	Parms.ScriptNameString = std::move(ScriptNameString);
	Parms.CreateScriptContextArgs = std::move(CreateScriptContextArgs);
	Parms.EventScriptProps = std::move(EventScriptProps);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.FindOrAddModuleScript
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ScriptNameString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCreateScriptContextArgs         CreateScriptContextArgs                                (Parm, NativeAccessSpecifierPublic)
// EScriptExecutionCategory                ModuleScriptExecutionCategory                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContext* UNiagaraEmitterConversionContext::FindOrAddModuleScript(const class FString& ScriptNameString, const struct FCreateScriptContextArgs& CreateScriptContextArgs, EScriptExecutionCategory ModuleScriptExecutionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "FindOrAddModuleScript");

	Params::NiagaraEmitterConversionContext_FindOrAddModuleScript Parms{};

	Parms.ScriptNameString = std::move(ScriptNameString);
	Parms.CreateScriptContextArgs = std::move(CreateScriptContextArgs);
	Parms.ModuleScriptExecutionCategory = ModuleScriptExecutionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.FindRenderer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RendererNameString                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraRendererProperties*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraRendererProperties* UNiagaraEmitterConversionContext::FindRenderer(const class FString& RendererNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "FindRenderer");

	Params::NiagaraEmitterConversionContext_FindRenderer Parms{};

	Parms.RendererNameString = std::move(RendererNameString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.GetAllRenderers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UNiagaraRendererProperties*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UNiagaraRendererProperties*> UNiagaraEmitterConversionContext::GetAllRenderers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "GetAllRenderers");

	Params::NiagaraEmitterConversionContext_GetAllRenderers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.GetEmitter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraEmitter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraEmitter* UNiagaraEmitterConversionContext::GetEmitter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "GetEmitter");

	Params::NiagaraEmitterConversionContext_GetEmitter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.Log
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraMessageSeverity                 Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsVerbose                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::Log(const class FString& Message, ENiagaraMessageSeverity Severity, bool bIsVerbose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "Log");

	Params::NiagaraEmitterConversionContext_Log Parms{};

	Parms.Message = std::move(Message);
	Parms.Severity = Severity;
	Parms.bIsVerbose = bIsVerbose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.RemoveModuleScriptsForAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FAssetData>               ScriptsToRemove                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::RemoveModuleScriptsForAssets(const TArray<struct FAssetData>& ScriptsToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "RemoveModuleScriptsForAssets");

	Params::NiagaraEmitterConversionContext_RemoveModuleScriptsForAssets Parms{};

	Parms.ScriptsToRemove = std::move(ScriptsToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetDetailBitMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetDetailBitMask(int32 BitMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetDetailBitMask");

	Params::NiagaraEmitterConversionContext_SetDetailBitMask Parms{};

	Parms.BitMask = BitMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetEnabled");

	Params::NiagaraEmitterConversionContext_SetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetLocalSpace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLocalSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetLocalSpace(bool bLocalSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetLocalSpace");

	Params::NiagaraEmitterConversionContext_SetLocalSpace Parms{};

	Parms.bLocalSpace = bLocalSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetParameterDirectly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ParameterNameString                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ParameterInput                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScriptExecutionCategory                SetParameterExecutionCategory                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetParameterDirectly(const class FString& ParameterNameString, class UNiagaraScriptConversionContextInput* ParameterInput, EScriptExecutionCategory SetParameterExecutionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetParameterDirectly");

	Params::NiagaraEmitterConversionContext_SetParameterDirectly Parms{};

	Parms.ParameterNameString = std::move(ParameterNameString);
	Parms.ParameterInput = ParameterInput;
	Parms.SetParameterExecutionCategory = SetParameterExecutionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetPastedFunctionCallNode
// (Final, Native, Private)
// Parameters:
// class UNiagaraNodeFunctionCall*         InFunctionCallNode                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetPastedFunctionCallNode(class UNiagaraNodeFunctionCall* InFunctionCallNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetPastedFunctionCallNode");

	Params::NiagaraEmitterConversionContext_SetPastedFunctionCallNode Parms{};

	Parms.InFunctionCallNode = InFunctionCallNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetRendererBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraRendererProperties*       InRendererProperties                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BindingName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VariableToBindName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraRendererSourceDataMode          SourceDataMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetRendererBinding(class UNiagaraRendererProperties* InRendererProperties, class FName BindingName, class FName VariableToBindName, ENiagaraRendererSourceDataMode SourceDataMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetRendererBinding");

	Params::NiagaraEmitterConversionContext_SetRendererBinding Parms{};

	Parms.InRendererProperties = InRendererProperties;
	Parms.BindingName = BindingName;
	Parms.VariableToBindName = VariableToBindName;
	Parms.SourceDataMode = SourceDataMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.SetSimTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENiagaraSimTarget                       InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraEmitterConversionContext::SetSimTarget(ENiagaraSimTarget InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "SetSimTarget");

	Params::NiagaraEmitterConversionContext_SetSimTarget Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraEmitterConversionContext.GetEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNiagaraEmitterConversionContext::GetEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraEmitterConversionContext", "GetEnabled");

	Params::NiagaraEmitterConversionContext_GetEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraScriptConversionContext.Log
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraMessageSeverity                 Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsVerbose                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraScriptConversionContext::Log(const class FString& Message, ENiagaraMessageSeverity Severity, bool bIsVerbose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraScriptConversionContext", "Log");

	Params::NiagaraScriptConversionContext_Log Parms{};

	Parms.Message = std::move(Message);
	Parms.Severity = Severity;
	Parms.bIsVerbose = bIsVerbose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraScriptConversionContext.SetModuleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInModuleEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraScriptConversionContext::SetModuleEnabled(bool bInModuleEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraScriptConversionContext", "SetModuleEnabled");

	Params::NiagaraScriptConversionContext_SetModuleEnabled Parms{};

	Parms.bInModuleEnabled = bInModuleEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.NiagaraScriptConversionContext.SetParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ParameterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ParameterInput                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInHasEditCondition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEditConditionValue                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNiagaraScriptConversionContext::SetParameter(const class FString& ParameterName, class UNiagaraScriptConversionContextInput* ParameterInput, bool bInHasEditCondition, bool bInEditConditionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraScriptConversionContext", "SetParameter");

	Params::NiagaraScriptConversionContext_SetParameter Parms{};

	Parms.ParameterName = std::move(ParameterName);
	Parms.ParameterInput = ParameterInput;
	Parms.bInHasEditCondition = bInHasEditCondition;
	Parms.bInEditConditionValue = bInEditConditionValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraScriptConversionContext.GetModuleEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNiagaraScriptConversionContext::GetModuleEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraScriptConversionContext", "GetModuleEnabled");

	Params::NiagaraScriptConversionContext_GetModuleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.NiagaraScriptConversionContextInput.Init
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UNiagaraClipboardFunctionInput*   InClipboardFunctionInput                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraScriptInputType                 InInputType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNiagaraTypeDefinition           InTypeDefinition                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNiagaraScriptConversionContextInput::Init(class UNiagaraClipboardFunctionInput* InClipboardFunctionInput, const ENiagaraScriptInputType InInputType, const struct FNiagaraTypeDefinition& InTypeDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NiagaraScriptConversionContextInput", "Init");

	Params::NiagaraScriptConversionContextInput_Init Parms{};

	Parms.InClipboardFunctionInput = InClipboardFunctionInput;
	Parms.InInputType = InInputType;
	Parms.InTypeDefinition = std::move(InTypeDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateAssetData
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAssetData                       ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAssetData UFXConverterUtilitiesLibrary::CreateAssetData(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateAssetData");

	Params::FXConverterUtilitiesLibrary_CreateAssetData Parms{};

	Parms.InPath = std::move(InPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateComponentRendererProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponentRendererProperties*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponentRendererProperties* UFXConverterUtilitiesLibrary::CreateComponentRendererProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateComponentRendererProperties");

	Params::FXConverterUtilitiesLibrary_CreateComponentRendererProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateFloatCurveDI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FRichCurveKeyBP>          Keys                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNiagaraDataInterfaceCurve*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraDataInterfaceCurve* UFXConverterUtilitiesLibrary::CreateFloatCurveDI(const TArray<struct FRichCurveKeyBP>& Keys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateFloatCurveDI");

	Params::FXConverterUtilitiesLibrary_CreateFloatCurveDI Parms{};

	Parms.Keys = std::move(Keys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateLightRendererProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraLightRendererProperties*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraLightRendererProperties* UFXConverterUtilitiesLibrary::CreateLightRendererProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateLightRendererProperties");

	Params::FXConverterUtilitiesLibrary_CreateLightRendererProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateMeshRendererProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraMeshRendererProperties*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraMeshRendererProperties* UFXConverterUtilitiesLibrary::CreateMeshRendererProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateMeshRendererProperties");

	Params::FXConverterUtilitiesLibrary_CreateMeshRendererProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateRibbonRendererProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraRibbonRendererProperties* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraRibbonRendererProperties* UFXConverterUtilitiesLibrary::CreateRibbonRendererProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateRibbonRendererProperties");

	Params::FXConverterUtilitiesLibrary_CreateRibbonRendererProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCreateScriptContextArgs         Args                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContext*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContext* UFXConverterUtilitiesLibrary::CreateScriptContext(const struct FCreateScriptContextArgs& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptContext");

	Params::FXConverterUtilitiesLibrary_CreateScriptContext Parms{};

	Parms.Args = std::move(Args);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputBool(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputBool");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputBool Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputDI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraDataInterface*            Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputDI(class UNiagaraDataInterface* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputDI");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputDI Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputDynamic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraScriptConversionContext*  Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraScriptInputType                 InputType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputDynamic(class UNiagaraScriptConversionContext* Value, ENiagaraScriptInputType InputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputDynamic");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputDynamic Parms{};

	Parms.Value = Value;
	Parms.InputType = InputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputEnum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserDefinedEnumAssetPath                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserDefinedEnumValueNameString                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputEnum(const class FString& UserDefinedEnumAssetPath, const class FString& UserDefinedEnumValueNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputEnum");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputEnum Parms{};

	Parms.UserDefinedEnumAssetPath = std::move(UserDefinedEnumAssetPath);
	Parms.UserDefinedEnumValueNameString = std::move(UserDefinedEnumValueNameString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputFloat");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputFloat Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputInt(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputInt");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputInt Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputLinkedParameter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ParameterNameString                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENiagaraScriptInputType                 InputType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputLinkedParameter(const class FString& ParameterNameString, ENiagaraScriptInputType InputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputLinkedParameter");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputLinkedParameter Parms{};

	Parms.ParameterNameString = std::move(ParameterNameString);
	Parms.InputType = InputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputStruct
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserDefinedStruct*               Value                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputStruct(class UUserDefinedStruct* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputStruct");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputStruct Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputVec2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputVec2(const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputVec2");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputVec2 Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateScriptInputVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraScriptConversionContextInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraScriptConversionContextInput* UFXConverterUtilitiesLibrary::CreateScriptInputVector(const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateScriptInputVector");

	Params::FXConverterUtilitiesLibrary_CreateScriptInputVector Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateSkeletalMeshDataInterface
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraDataInterfaceSkeletalMesh*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraDataInterfaceSkeletalMesh* UFXConverterUtilitiesLibrary::CreateSkeletalMeshDataInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateSkeletalMeshDataInterface");

	Params::FXConverterUtilitiesLibrary_CreateSkeletalMeshDataInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateSystemConversionContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   InSystem                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystemConversionContext*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystemConversionContext* UFXConverterUtilitiesLibrary::CreateSystemConversionContext(class UNiagaraSystem* InSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateSystemConversionContext");

	Params::FXConverterUtilitiesLibrary_CreateSystemConversionContext Parms{};

	Parms.InSystem = InSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateVec2CurveDI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FRichCurveKeyBP>          X_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          Y_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNiagaraDataInterfaceVector2DCurve*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraDataInterfaceVector2DCurve* UFXConverterUtilitiesLibrary::CreateVec2CurveDI(const TArray<struct FRichCurveKeyBP>& X_Keys, const TArray<struct FRichCurveKeyBP>& Y_Keys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateVec2CurveDI");

	Params::FXConverterUtilitiesLibrary_CreateVec2CurveDI Parms{};

	Parms.X_Keys = std::move(X_Keys);
	Parms.Y_Keys = std::move(Y_Keys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateVec3CurveDI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FRichCurveKeyBP>          X_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          Y_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          Z_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNiagaraDataInterfaceVectorCurve* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraDataInterfaceVectorCurve* UFXConverterUtilitiesLibrary::CreateVec3CurveDI(const TArray<struct FRichCurveKeyBP>& X_Keys, const TArray<struct FRichCurveKeyBP>& Y_Keys, const TArray<struct FRichCurveKeyBP>& Z_Keys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateVec3CurveDI");

	Params::FXConverterUtilitiesLibrary_CreateVec3CurveDI Parms{};

	Parms.X_Keys = std::move(X_Keys);
	Parms.Y_Keys = std::move(Y_Keys);
	Parms.Z_Keys = std::move(Z_Keys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.CreateVec4CurveDI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FRichCurveKeyBP>          X_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          Y_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          Z_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          W_Keys                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UNiagaraDataInterfaceVector4Curve*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraDataInterfaceVector4Curve* UFXConverterUtilitiesLibrary::CreateVec4CurveDI(const TArray<struct FRichCurveKeyBP>& X_Keys, const TArray<struct FRichCurveKeyBP>& Y_Keys, const TArray<struct FRichCurveKeyBP>& Z_Keys, const TArray<struct FRichCurveKeyBP>& W_Keys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "CreateVec4CurveDI");

	Params::FXConverterUtilitiesLibrary_CreateVec4CurveDI Parms{};

	Parms.X_Keys = std::move(X_Keys);
	Parms.Y_Keys = std::move(Y_Keys);
	Parms.Z_Keys = std::move(Z_Keys);
	Parms.W_Keys = std::move(W_Keys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetCascadeEmitterLodLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleEmitter*                 Emitter                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleLODLevel*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleLODLevel* UFXConverterUtilitiesLibrary::GetCascadeEmitterLodLevel(class UParticleEmitter* Emitter, const int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetCascadeEmitterLodLevel");

	Params::FXConverterUtilitiesLibrary_GetCascadeEmitterLodLevel Parms{};

	Parms.Emitter = Emitter;
	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetCascadeEmitterName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleEmitter*                 Emitter                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UFXConverterUtilitiesLibrary::GetCascadeEmitterName(class UParticleEmitter* Emitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetCascadeEmitterName");

	Params::FXConverterUtilitiesLibrary_GetCascadeEmitterName Parms{};

	Parms.Emitter = Emitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetCascadeEmitterRenderMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleEmitter*                 Emitter                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFXConverterUtilitiesLibrary::GetCascadeEmitterRenderMode(class UParticleEmitter* Emitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetCascadeEmitterRenderMode");

	Params::FXConverterUtilitiesLibrary_GetCascadeEmitterRenderMode Parms{};

	Parms.Emitter = Emitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetCascadeSystemEmitters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  System                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleEmitter*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UParticleEmitter*> UFXConverterUtilitiesLibrary::GetCascadeSystemEmitters(const class UParticleSystem* System)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetCascadeSystemEmitters");

	Params::FXConverterUtilitiesLibrary_GetCascadeSystemEmitters Parms{};

	Parms.System = System;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetDistributionLockedAxes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDistribution*                    Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EDistributionVectorLockFlags>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EDistributionVectorLockFlags> UFXConverterUtilitiesLibrary::GetDistributionLockedAxes(class UDistribution* Distribution)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetDistributionLockedAxes");

	Params::FXConverterUtilitiesLibrary_GetDistributionLockedAxes Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetDistributionMinMaxValues
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDistribution*                    Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetDistributionMinMaxValues(class UDistribution* Distribution, bool* bOutSuccess, struct FVector* OutMinValue, struct FVector* OutMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetDistributionMinMaxValues");

	Params::FXConverterUtilitiesLibrary_GetDistributionMinMaxValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	if (OutMinValue != nullptr)
		*OutMinValue = std::move(Parms.OutMinValue);

	if (OutMaxValue != nullptr)
		*OutMaxValue = std::move(Parms.OutMaxValue);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetDistributionType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistribution*                    Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDistributionType                       OutDistributionType                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDistributionValueType                  OutCascadeDistributionValueType                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetDistributionType(class UDistribution* Distribution, EDistributionType* OutDistributionType, EDistributionValueType* OutCascadeDistributionValueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetDistributionType");

	Params::FXConverterUtilitiesLibrary_GetDistributionType Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDistributionType != nullptr)
		*OutDistributionType = Parms.OutDistributionType;

	if (OutCascadeDistributionValueType != nullptr)
		*OutCascadeDistributionValueType = Parms.OutCascadeDistributionValueType;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetFloatDistributionConstCurveValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionFloatConstantCurve*  Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInterpCurveFloat                OutInterpCurveFloat                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetFloatDistributionConstCurveValues(class UDistributionFloatConstantCurve* Distribution, struct FInterpCurveFloat* OutInterpCurveFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetFloatDistributionConstCurveValues");

	Params::FXConverterUtilitiesLibrary_GetFloatDistributionConstCurveValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInterpCurveFloat != nullptr)
		*OutInterpCurveFloat = std::move(Parms.OutInterpCurveFloat);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetFloatDistributionConstValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionFloatConstant*       Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutConstFloat                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetFloatDistributionConstValues(class UDistributionFloatConstant* Distribution, float* OutConstFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetFloatDistributionConstValues");

	Params::FXConverterUtilitiesLibrary_GetFloatDistributionConstValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConstFloat != nullptr)
		*OutConstFloat = Parms.OutConstFloat;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetFloatDistributionParameterValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionFloatParameterBase*  Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutParameterName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMinInput                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMaxInput                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMinOutput                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMaxOutput                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetFloatDistributionParameterValues(class UDistributionFloatParameterBase* Distribution, class FName* OutParameterName, float* OutMinInput, float* OutMaxInput, float* OutMinOutput, float* OutMaxOutput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetFloatDistributionParameterValues");

	Params::FXConverterUtilitiesLibrary_GetFloatDistributionParameterValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutParameterName != nullptr)
		*OutParameterName = Parms.OutParameterName;

	if (OutMinInput != nullptr)
		*OutMinInput = Parms.OutMinInput;

	if (OutMaxInput != nullptr)
		*OutMaxInput = Parms.OutMaxInput;

	if (OutMinOutput != nullptr)
		*OutMinOutput = Parms.OutMinOutput;

	if (OutMaxOutput != nullptr)
		*OutMaxOutput = Parms.OutMaxOutput;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetFloatDistributionUniformCurveValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionFloatUniformCurve*   Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInterpCurveVector2D             OutInterpCurveVector2D                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetFloatDistributionUniformCurveValues(class UDistributionFloatUniformCurve* Distribution, struct FInterpCurveVector2D* OutInterpCurveVector2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetFloatDistributionUniformCurveValues");

	Params::FXConverterUtilitiesLibrary_GetFloatDistributionUniformCurveValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInterpCurveVector2D != nullptr)
		*OutInterpCurveVector2D = std::move(Parms.OutInterpCurveVector2D);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetFloatDistributionUniformValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionFloatUniform*        Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMax                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetFloatDistributionUniformValues(class UDistributionFloatUniform* Distribution, float* OutMin, float* OutMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetFloatDistributionUniformValues");

	Params::FXConverterUtilitiesLibrary_GetFloatDistributionUniformValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMin != nullptr)
		*OutMin = Parms.OutMin;

	if (OutMax != nullptr)
		*OutMax = Parms.OutMax;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLodLevelIsEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleLODLevel*                LodLevel                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFXConverterUtilitiesLibrary::GetLodLevelIsEnabled(class UParticleLODLevel* LodLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLodLevelIsEnabled");

	Params::FXConverterUtilitiesLibrary_GetLodLevelIsEnabled Parms{};

	Parms.LodLevel = LodLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLodLevelModules
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleLODLevel*                LodLevel                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleModule*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UParticleModule*> UFXConverterUtilitiesLibrary::GetLodLevelModules(class UParticleLODLevel* LodLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLodLevelModules");

	Params::FXConverterUtilitiesLibrary_GetLodLevelModules Parms{};

	Parms.LodLevel = LodLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLodLevelRequiredModule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleLODLevel*                LodLevel                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleModuleRequired*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleModuleRequired* UFXConverterUtilitiesLibrary::GetLodLevelRequiredModule(class UParticleLODLevel* LodLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLodLevelRequiredModule");

	Params::FXConverterUtilitiesLibrary_GetLodLevelRequiredModule Parms{};

	Parms.LodLevel = LodLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLodLevelSpawnModule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleLODLevel*                LodLevel                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleModuleSpawn*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleModuleSpawn* UFXConverterUtilitiesLibrary::GetLodLevelSpawnModule(class UParticleLODLevel* LodLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLodLevelSpawnModule");

	Params::FXConverterUtilitiesLibrary_GetLodLevelSpawnModule Parms{};

	Parms.LodLevel = LodLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLodLevelTypeDataModule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleLODLevel*                LodLevel                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleModuleTypeDataBase*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleModuleTypeDataBase* UFXConverterUtilitiesLibrary::GetLodLevelTypeDataModule(class UParticleLODLevel* LodLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLodLevelTypeDataModule");

	Params::FXConverterUtilitiesLibrary_GetLodLevelTypeDataModule Parms{};

	Parms.LodLevel = LodLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetLongPackagePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InLongPackageName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFXConverterUtilitiesLibrary::GetLongPackagePath(const class FString& InLongPackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetLongPackagePath");

	Params::FXConverterUtilitiesLibrary_GetLongPackagePath Parms{};

	Parms.InLongPackageName = std::move(InLongPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAccelerationDragProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAccelerationDrag*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutDragCoefficientRaw                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAccelerationDragProps(class UParticleModuleAccelerationDrag* ParticleModule, class UDistribution** OutDragCoefficientRaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAccelerationDragProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAccelerationDragProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDragCoefficientRaw != nullptr)
		*OutDragCoefficientRaw = Parms.OutDragCoefficientRaw;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAccelerationDragScaleOverLifeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAccelerationDragScaleOverLife*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutDragScaleRaw                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAccelerationDragScaleOverLifeProps(class UParticleModuleAccelerationDragScaleOverLife* ParticleModule, class UDistribution** OutDragScaleRaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAccelerationDragScaleOverLifeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAccelerationDragScaleOverLifeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDragScaleRaw != nullptr)
		*OutDragScaleRaw = Parms.OutDragScaleRaw;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAccelerationOverLifetimeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAccelerationOverLifetime*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutAccelOverLife                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAccelerationOverLifetimeProps(class UParticleModuleAccelerationOverLifetime* ParticleModule, class UDistribution** OutAccelOverLife)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAccelerationOverLifetimeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAccelerationOverLifetimeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAccelOverLife != nullptr)
		*OutAccelOverLife = Parms.OutAccelOverLife;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAccelerationProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAcceleration*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutAcceleration                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyOwnerScale                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAccelerationProps(class UParticleModuleAcceleration* ParticleModule, class UDistribution** OutAcceleration, bool* bOutApplyOwnerScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAccelerationProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAccelerationProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAcceleration != nullptr)
		*OutAcceleration = Parms.OutAcceleration;

	if (bOutApplyOwnerScale != nullptr)
		*bOutApplyOwnerScale = Parms.bOutApplyOwnerScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAttractorLineProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleAttractorLine*     ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutStartPoint                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutEndPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRange                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStrength                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAttractorLineProps(class UParticleModuleAttractorLine* ParticleModule, struct FVector* OutStartPoint, struct FVector* OutEndPoint, class UDistribution** OutRange, class UDistribution** OutStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAttractorLineProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAttractorLineProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartPoint != nullptr)
		*OutStartPoint = std::move(Parms.OutStartPoint);

	if (OutEndPoint != nullptr)
		*OutEndPoint = std::move(Parms.OutEndPoint);

	if (OutRange != nullptr)
		*OutRange = Parms.OutRange;

	if (OutStrength != nullptr)
		*OutStrength = Parms.OutStrength;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAttractorParticleProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAttractorParticle* ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutEmitterName                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRange                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutStrengthByDistance                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStrength                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutAffectBaseVelocity                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttractorParticleSelectionMethod       OutSelectionMethod                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRenewSource                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInheritSourceVelocity                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAttractorParticleProps(class UParticleModuleAttractorParticle* ParticleModule, class FName* OutEmitterName, class UDistribution** OutRange, bool* bOutStrengthByDistance, class UDistribution** OutStrength, bool* bOutAffectBaseVelocity, EAttractorParticleSelectionMethod* OutSelectionMethod, bool* bOutRenewSource, bool* bOutInheritSourceVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAttractorParticleProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAttractorParticleProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEmitterName != nullptr)
		*OutEmitterName = Parms.OutEmitterName;

	if (OutRange != nullptr)
		*OutRange = Parms.OutRange;

	if (bOutStrengthByDistance != nullptr)
		*bOutStrengthByDistance = Parms.bOutStrengthByDistance;

	if (OutStrength != nullptr)
		*OutStrength = Parms.OutStrength;

	if (bOutAffectBaseVelocity != nullptr)
		*bOutAffectBaseVelocity = Parms.bOutAffectBaseVelocity;

	if (OutSelectionMethod != nullptr)
		*OutSelectionMethod = Parms.OutSelectionMethod;

	if (bOutRenewSource != nullptr)
		*bOutRenewSource = Parms.bOutRenewSource;

	if (bOutInheritSourceVelocity != nullptr)
		*bOutInheritSourceVelocity = Parms.bOutInheritSourceVelocity;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleAttractorPointProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleAttractorPoint*    ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutPosition                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRange                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStrength                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    boutStrengthByDistance                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutAffectsBaseVelocity                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOverrideVelocity                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseWorldSpacePosition                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleAttractorPointProps(class UParticleModuleAttractorPoint* ParticleModule, class UDistribution** OutPosition, class UDistribution** OutRange, class UDistribution** OutStrength, bool* boutStrengthByDistance, bool* bOutAffectsBaseVelocity, bool* bOutOverrideVelocity, bool* bOutUseWorldSpacePosition, bool* bOutPositiveX, bool* bOutPositiveY, bool* bOutPositiveZ, bool* bOutNegativeX, bool* bOutNegativeY, bool* bOutNegativeZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleAttractorPointProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleAttractorPointProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = Parms.OutPosition;

	if (OutRange != nullptr)
		*OutRange = Parms.OutRange;

	if (OutStrength != nullptr)
		*OutStrength = Parms.OutStrength;

	if (boutStrengthByDistance != nullptr)
		*boutStrengthByDistance = Parms.boutStrengthByDistance;

	if (bOutAffectsBaseVelocity != nullptr)
		*bOutAffectsBaseVelocity = Parms.bOutAffectsBaseVelocity;

	if (bOutOverrideVelocity != nullptr)
		*bOutOverrideVelocity = Parms.bOutOverrideVelocity;

	if (bOutUseWorldSpacePosition != nullptr)
		*bOutUseWorldSpacePosition = Parms.bOutUseWorldSpacePosition;

	if (bOutPositiveX != nullptr)
		*bOutPositiveX = Parms.bOutPositiveX;

	if (bOutPositiveY != nullptr)
		*bOutPositiveY = Parms.bOutPositiveY;

	if (bOutPositiveZ != nullptr)
		*bOutPositiveZ = Parms.bOutPositiveZ;

	if (bOutNegativeX != nullptr)
		*bOutNegativeX = Parms.bOutNegativeX;

	if (bOutNegativeY != nullptr)
		*bOutNegativeY = Parms.bOutNegativeY;

	if (bOutNegativeZ != nullptr)
		*bOutNegativeZ = Parms.bOutNegativeZ;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleCameraOffsetProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleCameraOffset*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutCameraOffset                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutSpawnTimeOnly                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleCameraOffsetUpdateMethod       OutUpdateMethod                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleCameraOffsetProps(class UParticleModuleCameraOffset* ParticleModule, class UDistribution** OutCameraOffset, bool* bOutSpawnTimeOnly, EParticleCameraOffsetUpdateMethod* OutUpdateMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleCameraOffsetProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleCameraOffsetProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraOffset != nullptr)
		*OutCameraOffset = Parms.OutCameraOffset;

	if (bOutSpawnTimeOnly != nullptr)
		*bOutSpawnTimeOnly = Parms.bOutSpawnTimeOnly;

	if (OutUpdateMethod != nullptr)
		*OutUpdateMethod = Parms.OutUpdateMethod;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleCollisionProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleCollision*         ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutDampingFactor                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutDampingFactorRotation                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutMaxCollisions                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleCollisionComplete              OutCollisionCompleteOption                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                OutCollisionTypes                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bOutApplyPhysics                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreTriggerVolumes                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutParticleMass                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDirScalar                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPawnsDoNotDecrementCount                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOnlyVerticalNormalsDecrementCount                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutVerticalFudgeFactor                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutDelayAmount                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutDropDetail                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutCollideOnlyIfVisible                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreSourceActor                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMaxCollisionDistance                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleCollisionProps(class UParticleModuleCollision* ParticleModule, class UDistribution** OutDampingFactor, class UDistribution** OutDampingFactorRotation, class UDistribution** OutMaxCollisions, EParticleCollisionComplete* OutCollisionCompleteOption, TArray<EObjectTypeQuery>* OutCollisionTypes, bool* bOutApplyPhysics, bool* bOutIgnoreTriggerVolumes, class UDistribution** OutParticleMass, float* OutDirScalar, bool* bOutPawnsDoNotDecrementCount, bool* bOutOnlyVerticalNormalsDecrementCount, float* OutVerticalFudgeFactor, class UDistribution** OutDelayAmount, bool* bOutDropDetail, bool* bOutCollideOnlyIfVisible, bool* bOutIgnoreSourceActor, float* OutMaxCollisionDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleCollisionProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleCollisionProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDampingFactor != nullptr)
		*OutDampingFactor = Parms.OutDampingFactor;

	if (OutDampingFactorRotation != nullptr)
		*OutDampingFactorRotation = Parms.OutDampingFactorRotation;

	if (OutMaxCollisions != nullptr)
		*OutMaxCollisions = Parms.OutMaxCollisions;

	if (OutCollisionCompleteOption != nullptr)
		*OutCollisionCompleteOption = Parms.OutCollisionCompleteOption;

	if (OutCollisionTypes != nullptr)
		*OutCollisionTypes = std::move(Parms.OutCollisionTypes);

	if (bOutApplyPhysics != nullptr)
		*bOutApplyPhysics = Parms.bOutApplyPhysics;

	if (bOutIgnoreTriggerVolumes != nullptr)
		*bOutIgnoreTriggerVolumes = Parms.bOutIgnoreTriggerVolumes;

	if (OutParticleMass != nullptr)
		*OutParticleMass = Parms.OutParticleMass;

	if (OutDirScalar != nullptr)
		*OutDirScalar = Parms.OutDirScalar;

	if (bOutPawnsDoNotDecrementCount != nullptr)
		*bOutPawnsDoNotDecrementCount = Parms.bOutPawnsDoNotDecrementCount;

	if (bOutOnlyVerticalNormalsDecrementCount != nullptr)
		*bOutOnlyVerticalNormalsDecrementCount = Parms.bOutOnlyVerticalNormalsDecrementCount;

	if (OutVerticalFudgeFactor != nullptr)
		*OutVerticalFudgeFactor = Parms.OutVerticalFudgeFactor;

	if (OutDelayAmount != nullptr)
		*OutDelayAmount = Parms.OutDelayAmount;

	if (bOutDropDetail != nullptr)
		*bOutDropDetail = Parms.bOutDropDetail;

	if (bOutCollideOnlyIfVisible != nullptr)
		*bOutCollideOnlyIfVisible = Parms.bOutCollideOnlyIfVisible;

	if (bOutIgnoreSourceActor != nullptr)
		*bOutIgnoreSourceActor = Parms.bOutIgnoreSourceActor;

	if (OutMaxCollisionDistance != nullptr)
		*OutMaxCollisionDistance = Parms.OutMaxCollisionDistance;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleColorOverLifeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleColorOverLife*     ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutColorOverLife                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutAlphaOverLife                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutClampAlpha                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleColorOverLifeProps(class UParticleModuleColorOverLife* ParticleModule, class UDistribution** OutColorOverLife, class UDistribution** OutAlphaOverLife, bool* bOutClampAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleColorOverLifeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleColorOverLifeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutColorOverLife != nullptr)
		*OutColorOverLife = Parms.OutColorOverLife;

	if (OutAlphaOverLife != nullptr)
		*OutAlphaOverLife = Parms.OutAlphaOverLife;

	if (bOutClampAlpha != nullptr)
		*bOutClampAlpha = Parms.bOutClampAlpha;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleColorProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleColor*             ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartColor                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartAlpha                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutClampAlpha                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleColorProps(class UParticleModuleColor* ParticleModule, class UDistribution** OutStartColor, class UDistribution** OutStartAlpha, bool* bOutClampAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleColorProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleColorProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartColor != nullptr)
		*OutStartColor = Parms.OutStartColor;

	if (OutStartAlpha != nullptr)
		*OutStartAlpha = Parms.OutStartAlpha;

	if (bOutClampAlpha != nullptr)
		*bOutClampAlpha = Parms.bOutClampAlpha;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleColorScaleOverLifeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleColorScaleOverLife*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutColorScaleOverLife                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutAlphaScaleOverLife                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEmitterTime                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleColorScaleOverLifeProps(class UParticleModuleColorScaleOverLife* ParticleModule, class UDistribution** OutColorScaleOverLife, class UDistribution** OutAlphaScaleOverLife, bool* bOutEmitterTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleColorScaleOverLifeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleColorScaleOverLifeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutColorScaleOverLife != nullptr)
		*OutColorScaleOverLife = Parms.OutColorScaleOverLife;

	if (OutAlphaScaleOverLife != nullptr)
		*OutAlphaScaleOverLife = Parms.OutAlphaScaleOverLife;

	if (bOutEmitterTime != nullptr)
		*bOutEmitterTime = Parms.bOutEmitterTime;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleConstantAccelerationProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleAccelerationConstant*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutConstAcceleration                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleConstantAccelerationProps(class UParticleModuleAccelerationConstant* ParticleModule, struct FVector* OutConstAcceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleConstantAccelerationProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleConstantAccelerationProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConstAcceleration != nullptr)
		*OutConstAcceleration = std::move(Parms.OutConstAcceleration);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleKillBoxProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleKillBox*           ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLowerLeftCorner                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutUpperRightCorner                                    (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutWorldSpaceCoords                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutKillInside                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutAxisAlignedAndFixedSize                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleKillBoxProps(class UParticleModuleKillBox* ParticleModule, class UDistribution** OutLowerLeftCorner, class UDistribution** OutUpperRightCorner, bool* bOutWorldSpaceCoords, bool* bOutKillInside, bool* bOutAxisAlignedAndFixedSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleKillBoxProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleKillBoxProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLowerLeftCorner != nullptr)
		*OutLowerLeftCorner = Parms.OutLowerLeftCorner;

	if (OutUpperRightCorner != nullptr)
		*OutUpperRightCorner = Parms.OutUpperRightCorner;

	if (bOutWorldSpaceCoords != nullptr)
		*bOutWorldSpaceCoords = Parms.bOutWorldSpaceCoords;

	if (bOutKillInside != nullptr)
		*bOutKillInside = Parms.bOutKillInside;

	if (bOutAxisAlignedAndFixedSize != nullptr)
		*bOutAxisAlignedAndFixedSize = Parms.bOutAxisAlignedAndFixedSize;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLifetimeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLifetime*          ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLifetime                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLifetimeProps(class UParticleModuleLifetime* ParticleModule, class UDistribution** OutLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLifetimeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLifetimeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLifetime != nullptr)
		*OutLifetime = Parms.OutLifetime;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLightProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLight*             ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseInverseSquaredFalloff                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutAffectsTranslucency                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPreviewLightRadius                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSpawnFraction                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutColorScaleOverLife                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutBrightnessOverLife                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRadiusScale                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLightExponent                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLightingChannels                OutLightingChannels                                    (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OutVolumetricScatteringIntensity                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutHighQualityLights                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutShadowCastingLights                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLightProps(class UParticleModuleLight* ParticleModule, bool* bOutUseInverseSquaredFalloff, bool* bOutAffectsTranslucency, bool* bOutPreviewLightRadius, float* OutSpawnFraction, class UDistribution** OutColorScaleOverLife, class UDistribution** OutBrightnessOverLife, class UDistribution** OutRadiusScale, class UDistribution** OutLightExponent, struct FLightingChannels* OutLightingChannels, float* OutVolumetricScatteringIntensity, bool* bOutHighQualityLights, bool* bOutShadowCastingLights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLightProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLightProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUseInverseSquaredFalloff != nullptr)
		*bOutUseInverseSquaredFalloff = Parms.bOutUseInverseSquaredFalloff;

	if (bOutAffectsTranslucency != nullptr)
		*bOutAffectsTranslucency = Parms.bOutAffectsTranslucency;

	if (bOutPreviewLightRadius != nullptr)
		*bOutPreviewLightRadius = Parms.bOutPreviewLightRadius;

	if (OutSpawnFraction != nullptr)
		*OutSpawnFraction = Parms.OutSpawnFraction;

	if (OutColorScaleOverLife != nullptr)
		*OutColorScaleOverLife = Parms.OutColorScaleOverLife;

	if (OutBrightnessOverLife != nullptr)
		*OutBrightnessOverLife = Parms.OutBrightnessOverLife;

	if (OutRadiusScale != nullptr)
		*OutRadiusScale = Parms.OutRadiusScale;

	if (OutLightExponent != nullptr)
		*OutLightExponent = Parms.OutLightExponent;

	if (OutLightingChannels != nullptr)
		*OutLightingChannels = std::move(Parms.OutLightingChannels);

	if (OutVolumetricScatteringIntensity != nullptr)
		*OutVolumetricScatteringIntensity = Parms.OutVolumetricScatteringIntensity;

	if (bOutHighQualityLights != nullptr)
		*bOutHighQualityLights = Parms.bOutHighQualityLights;

	if (bOutShadowCastingLights != nullptr)
		*bOutShadowCastingLights = Parms.bOutShadowCastingLights;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLocationBoneSocketProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleLocationBoneSocket*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocationBoneSocketSource               OutSourceType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutUniversalOffset                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLocationBoneSocketInfoBP>OutSourceLocations                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// ELocationBoneSocketSelectionMethod      OutSelectionMethod                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUpdatePositionEachFrame                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOrientMeshEmitters                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInheritBoneVelocity                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutInheritVelocityScale                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutSkelMeshActorParamName                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutNumPreSelectedIndices                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutEditorSkelMesh                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLocationBoneSocketProps(class UParticleModuleLocationBoneSocket* ParticleModule, ELocationBoneSocketSource* OutSourceType, struct FVector* OutUniversalOffset, TArray<struct FLocationBoneSocketInfoBP>* OutSourceLocations, ELocationBoneSocketSelectionMethod* OutSelectionMethod, bool* bOutUpdatePositionEachFrame, bool* bOutOrientMeshEmitters, bool* bOutInheritBoneVelocity, float* OutInheritVelocityScale, class FName* OutSkelMeshActorParamName, int32* OutNumPreSelectedIndices, class USkeletalMesh** OutEditorSkelMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLocationBoneSocketProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLocationBoneSocketProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSourceType != nullptr)
		*OutSourceType = Parms.OutSourceType;

	if (OutUniversalOffset != nullptr)
		*OutUniversalOffset = std::move(Parms.OutUniversalOffset);

	if (OutSourceLocations != nullptr)
		*OutSourceLocations = std::move(Parms.OutSourceLocations);

	if (OutSelectionMethod != nullptr)
		*OutSelectionMethod = Parms.OutSelectionMethod;

	if (bOutUpdatePositionEachFrame != nullptr)
		*bOutUpdatePositionEachFrame = Parms.bOutUpdatePositionEachFrame;

	if (bOutOrientMeshEmitters != nullptr)
		*bOutOrientMeshEmitters = Parms.bOutOrientMeshEmitters;

	if (bOutInheritBoneVelocity != nullptr)
		*bOutInheritBoneVelocity = Parms.bOutInheritBoneVelocity;

	if (OutInheritVelocityScale != nullptr)
		*OutInheritVelocityScale = Parms.OutInheritVelocityScale;

	if (OutSkelMeshActorParamName != nullptr)
		*OutSkelMeshActorParamName = Parms.OutSkelMeshActorParamName;

	if (OutNumPreSelectedIndices != nullptr)
		*OutNumPreSelectedIndices = Parms.OutNumPreSelectedIndices;

	if (OutEditorSkelMesh != nullptr)
		*OutEditorSkelMesh = Parms.OutEditorSkelMesh;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLocationDirectProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLocationDirect*    ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLocation                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLocationOffset                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutScaleFactor                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLocationDirectProps(class UParticleModuleLocationDirect* ParticleModule, class UDistribution** OutLocation, class UDistribution** OutLocationOffset, class UDistribution** OutScaleFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLocationDirectProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLocationDirectProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = Parms.OutLocation;

	if (OutLocationOffset != nullptr)
		*OutLocationOffset = Parms.OutLocationOffset;

	if (OutScaleFactor != nullptr)
		*OutScaleFactor = Parms.OutScaleFactor;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLocationPrimitiveCylinderProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLocationPrimitiveCylinder*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRadialVelocity                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRadius                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartHeight                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECylinderHeightAxis                     OutHeightAxis                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutSurfaceOnly                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutVelocity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutVelocityScale                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartLocation                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLocationPrimitiveCylinderProps(class UParticleModuleLocationPrimitiveCylinder* ParticleModule, bool* bOutRadialVelocity, class UDistribution** OutStartRadius, class UDistribution** OutStartHeight, ECylinderHeightAxis* OutHeightAxis, bool* bOutPositiveX, bool* bOutPositiveY, bool* bOutPositiveZ, bool* bOutNegativeX, bool* bOutNegativeY, bool* bOutNegativeZ, bool* bOutSurfaceOnly, bool* bOutVelocity, class UDistribution** OutVelocityScale, class UDistribution** OutStartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLocationPrimitiveCylinderProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLocationPrimitiveCylinderProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutRadialVelocity != nullptr)
		*bOutRadialVelocity = Parms.bOutRadialVelocity;

	if (OutStartRadius != nullptr)
		*OutStartRadius = Parms.OutStartRadius;

	if (OutStartHeight != nullptr)
		*OutStartHeight = Parms.OutStartHeight;

	if (OutHeightAxis != nullptr)
		*OutHeightAxis = Parms.OutHeightAxis;

	if (bOutPositiveX != nullptr)
		*bOutPositiveX = Parms.bOutPositiveX;

	if (bOutPositiveY != nullptr)
		*bOutPositiveY = Parms.bOutPositiveY;

	if (bOutPositiveZ != nullptr)
		*bOutPositiveZ = Parms.bOutPositiveZ;

	if (bOutNegativeX != nullptr)
		*bOutNegativeX = Parms.bOutNegativeX;

	if (bOutNegativeY != nullptr)
		*bOutNegativeY = Parms.bOutNegativeY;

	if (bOutNegativeZ != nullptr)
		*bOutNegativeZ = Parms.bOutNegativeZ;

	if (bOutSurfaceOnly != nullptr)
		*bOutSurfaceOnly = Parms.bOutSurfaceOnly;

	if (bOutVelocity != nullptr)
		*bOutVelocity = Parms.bOutVelocity;

	if (OutVelocityScale != nullptr)
		*OutVelocityScale = Parms.OutVelocityScale;

	if (OutStartLocation != nullptr)
		*OutStartLocation = Parms.OutStartLocation;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLocationPrimitiveSphereProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLocationPrimitiveSphere*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRadius                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutPositiveZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeX                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeY                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutNegativeZ                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutSurfaceOnly                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutVelocity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutVelocityScale                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartLocation                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLocationPrimitiveSphereProps(class UParticleModuleLocationPrimitiveSphere* ParticleModule, class UDistribution** OutStartRadius, bool* bOutPositiveX, bool* bOutPositiveY, bool* bOutPositiveZ, bool* bOutNegativeX, bool* bOutNegativeY, bool* bOutNegativeZ, bool* bOutSurfaceOnly, bool* bOutVelocity, class UDistribution** OutVelocityScale, class UDistribution** OutStartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLocationPrimitiveSphereProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLocationPrimitiveSphereProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartRadius != nullptr)
		*OutStartRadius = Parms.OutStartRadius;

	if (bOutPositiveX != nullptr)
		*bOutPositiveX = Parms.bOutPositiveX;

	if (bOutPositiveY != nullptr)
		*bOutPositiveY = Parms.bOutPositiveY;

	if (bOutPositiveZ != nullptr)
		*bOutPositiveZ = Parms.bOutPositiveZ;

	if (bOutNegativeX != nullptr)
		*bOutNegativeX = Parms.bOutNegativeX;

	if (bOutNegativeY != nullptr)
		*bOutNegativeY = Parms.bOutNegativeY;

	if (bOutNegativeZ != nullptr)
		*bOutNegativeZ = Parms.bOutNegativeZ;

	if (bOutSurfaceOnly != nullptr)
		*bOutSurfaceOnly = Parms.bOutSurfaceOnly;

	if (bOutVelocity != nullptr)
		*bOutVelocity = Parms.bOutVelocity;

	if (OutVelocityScale != nullptr)
		*OutVelocityScale = Parms.OutVelocityScale;

	if (OutStartLocation != nullptr)
		*OutStartLocation = Parms.OutStartLocation;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleLocationProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleLocation*          ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartLocation                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistributeOverNPoints                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistributeThreshold                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleLocationProps(class UParticleModuleLocation* ParticleModule, class UDistribution** OutStartLocation, float* OutDistributeOverNPoints, float* OutDistributeThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleLocationProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleLocationProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartLocation != nullptr)
		*OutStartLocation = Parms.OutStartLocation;

	if (OutDistributeOverNPoints != nullptr)
		*OutDistributeOverNPoints = Parms.OutDistributeOverNPoints;

	if (OutDistributeThreshold != nullptr)
		*OutDistributeThreshold = Parms.OutDistributeThreshold;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleMeshMaterialProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleMeshMaterial*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInterface*>       OutMeshMaterials                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleMeshMaterialProps(class UParticleModuleMeshMaterial* ParticleModule, TArray<class UMaterialInterface*>* OutMeshMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleMeshMaterialProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleMeshMaterialProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMeshMaterials != nullptr)
		*OutMeshMaterials = std::move(Parms.OutMeshMaterials);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleMeshRotationProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleMeshRotation*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRotation                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInheritParentRotation                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleMeshRotationProps(class UParticleModuleMeshRotation* ParticleModule, class UDistribution** OutStartRotation, bool* bOutInheritParentRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleMeshRotationProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleMeshRotationProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartRotation != nullptr)
		*OutStartRotation = Parms.OutStartRotation;

	if (bOutInheritParentRotation != nullptr)
		*bOutInheritParentRotation = Parms.bOutInheritParentRotation;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleMeshRotationRateMultiplyLifeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleMeshRotationRateMultiplyLife*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLifeMultiplier                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleMeshRotationRateMultiplyLifeProps(class UParticleModuleMeshRotationRateMultiplyLife* ParticleModule, class UDistribution** OutLifeMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleMeshRotationRateMultiplyLifeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleMeshRotationRateMultiplyLifeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLifeMultiplier != nullptr)
		*OutLifeMultiplier = Parms.OutLifeMultiplier;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleMeshRotationRateProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleMeshRotationRate*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRotationRate                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleMeshRotationRateProps(class UParticleModuleMeshRotationRate* ParticleModule, class UDistribution** OutStartRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleMeshRotationRateProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleMeshRotationRateProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartRotationRate != nullptr)
		*OutStartRotationRate = Parms.OutStartRotationRate;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleOrbitProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleOrbit*             ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrbitChainMode                         OutChainMode                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutOffsetAmount                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrbitOptionsBP                  OutOffsetOptions                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRotationAmount                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrbitOptionsBP                  OutRotationOptions                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRotationRateAmount                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrbitOptionsBP                  OutRotationRateOptions                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleOrbitProps(class UParticleModuleOrbit* ParticleModule, EOrbitChainMode* OutChainMode, class UDistribution** OutOffsetAmount, struct FOrbitOptionsBP* OutOffsetOptions, class UDistribution** OutRotationAmount, struct FOrbitOptionsBP* OutRotationOptions, class UDistribution** OutRotationRateAmount, struct FOrbitOptionsBP* OutRotationRateOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleOrbitProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleOrbitProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChainMode != nullptr)
		*OutChainMode = Parms.OutChainMode;

	if (OutOffsetAmount != nullptr)
		*OutOffsetAmount = Parms.OutOffsetAmount;

	if (OutOffsetOptions != nullptr)
		*OutOffsetOptions = std::move(Parms.OutOffsetOptions);

	if (OutRotationAmount != nullptr)
		*OutRotationAmount = Parms.OutRotationAmount;

	if (OutRotationOptions != nullptr)
		*OutRotationOptions = std::move(Parms.OutRotationOptions);

	if (OutRotationRateAmount != nullptr)
		*OutRotationRateAmount = Parms.OutRotationRateAmount;

	if (OutRotationRateOptions != nullptr)
		*OutRotationRateOptions = std::move(Parms.OutRotationRateOptions);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleOrientationAxisLockProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleOrientationAxisLock*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleAxisLock                       OutLockAxisFlags                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleOrientationAxisLockProps(class UParticleModuleOrientationAxisLock* ParticleModule, EParticleAxisLock* OutLockAxisFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleOrientationAxisLockProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleOrientationAxisLockProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLockAxisFlags != nullptr)
		*OutLockAxisFlags = Parms.OutLockAxisFlags;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleParameterDynamicProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleParameterDynamic*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FEmitterDynamicParameterBP>OutDynamicParams                                       (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bOutUsesVelocity                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleParameterDynamicProps(class UParticleModuleParameterDynamic* ParticleModule, TArray<struct FEmitterDynamicParameterBP>* OutDynamicParams, bool* bOutUsesVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleParameterDynamicProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleParameterDynamicProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDynamicParams != nullptr)
		*OutDynamicParams = std::move(Parms.OutDynamicParams);

	if (bOutUsesVelocity != nullptr)
		*bOutUsesVelocity = Parms.bOutUsesVelocity;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModulePivotOffsetProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModulePivotOffset*       ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutPivotOffset                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModulePivotOffsetProps(class UParticleModulePivotOffset* ParticleModule, struct FVector2D* OutPivotOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModulePivotOffsetProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModulePivotOffsetProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPivotOffset != nullptr)
		*OutPivotOffset = std::move(Parms.OutPivotOffset);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRequiredPerEmitterProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleRequired*          ParticleModuleRequired                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutEmitterOrigin                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutEmitterRotation                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutUseLocalSpace                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutKillOnDeactivate                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutKillOnCompleted                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseLegacyEmitterTime                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEmitterDurationUseRange                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutEmitterDuration                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutEmitterDurationLow                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOUtEmitterDelayUseRange                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutDelayFirstLoopOnly                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutEmitterDelay                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutEmitterDelayLow                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutDurationRecalcEachLoop                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutEmitterLoops                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRequiredPerEmitterProps(class UParticleModuleRequired* ParticleModuleRequired, struct FVector* OutEmitterOrigin, struct FRotator* OutEmitterRotation, bool* bOutUseLocalSpace, bool* bOutKillOnDeactivate, bool* bOutKillOnCompleted, bool* bOutUseLegacyEmitterTime, bool* bOutEmitterDurationUseRange, float* OutEmitterDuration, float* OutEmitterDurationLow, bool* bOUtEmitterDelayUseRange, bool* bOutDelayFirstLoopOnly, float* OutEmitterDelay, float* OutEmitterDelayLow, bool* bOutDurationRecalcEachLoop, int32* OutEmitterLoops)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRequiredPerEmitterProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRequiredPerEmitterProps Parms{};

	Parms.ParticleModuleRequired = ParticleModuleRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEmitterOrigin != nullptr)
		*OutEmitterOrigin = std::move(Parms.OutEmitterOrigin);

	if (OutEmitterRotation != nullptr)
		*OutEmitterRotation = std::move(Parms.OutEmitterRotation);

	if (bOutUseLocalSpace != nullptr)
		*bOutUseLocalSpace = Parms.bOutUseLocalSpace;

	if (bOutKillOnDeactivate != nullptr)
		*bOutKillOnDeactivate = Parms.bOutKillOnDeactivate;

	if (bOutKillOnCompleted != nullptr)
		*bOutKillOnCompleted = Parms.bOutKillOnCompleted;

	if (bOutUseLegacyEmitterTime != nullptr)
		*bOutUseLegacyEmitterTime = Parms.bOutUseLegacyEmitterTime;

	if (bOutEmitterDurationUseRange != nullptr)
		*bOutEmitterDurationUseRange = Parms.bOutEmitterDurationUseRange;

	if (OutEmitterDuration != nullptr)
		*OutEmitterDuration = Parms.OutEmitterDuration;

	if (OutEmitterDurationLow != nullptr)
		*OutEmitterDurationLow = Parms.OutEmitterDurationLow;

	if (bOUtEmitterDelayUseRange != nullptr)
		*bOUtEmitterDelayUseRange = Parms.bOUtEmitterDelayUseRange;

	if (bOutDelayFirstLoopOnly != nullptr)
		*bOutDelayFirstLoopOnly = Parms.bOutDelayFirstLoopOnly;

	if (OutEmitterDelay != nullptr)
		*OutEmitterDelay = Parms.OutEmitterDelay;

	if (OutEmitterDelayLow != nullptr)
		*OutEmitterDelayLow = Parms.OutEmitterDelayLow;

	if (bOutDurationRecalcEachLoop != nullptr)
		*bOutDurationRecalcEachLoop = Parms.bOutDurationRecalcEachLoop;

	if (OutEmitterLoops != nullptr)
		*OutEmitterLoops = Parms.OutEmitterLoops;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRequiredPerModuleProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleRequired*          ParticleModuleRequired                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOrbitModuleAffectsVelocityAlignment                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRandomImageTime                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutRandomImageChanges                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOverrideSystemMacroUV                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMacroUVPosition                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMacroUVRadius                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRequiredPerModuleProps(class UParticleModuleRequired* ParticleModuleRequired, bool* bOutOrbitModuleAffectsVelocityAlignment, float* OutRandomImageTime, int32* OutRandomImageChanges, bool* bOutOverrideSystemMacroUV, struct FVector* OutMacroUVPosition, float* OutMacroUVRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRequiredPerModuleProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRequiredPerModuleProps Parms{};

	Parms.ParticleModuleRequired = ParticleModuleRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutOrbitModuleAffectsVelocityAlignment != nullptr)
		*bOutOrbitModuleAffectsVelocityAlignment = Parms.bOutOrbitModuleAffectsVelocityAlignment;

	if (OutRandomImageTime != nullptr)
		*OutRandomImageTime = Parms.OutRandomImageTime;

	if (OutRandomImageChanges != nullptr)
		*OutRandomImageChanges = Parms.OutRandomImageChanges;

	if (bOutOverrideSystemMacroUV != nullptr)
		*bOutOverrideSystemMacroUV = Parms.bOutOverrideSystemMacroUV;

	if (OutMacroUVPosition != nullptr)
		*OutMacroUVPosition = std::move(Parms.OutMacroUVPosition);

	if (OutMacroUVRadius != nullptr)
		*OutMacroUVRadius = Parms.OutMacroUVRadius;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRequiredPerRendererProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleRequired*          ParticleModuleRequired                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               OutMaterialInterface                                   (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleScreenAlignment                OutScreenAlignment                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSubImages_Horizontal                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSubImages_Vertical                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleSortMode                       OutSortMode                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleSubUVInterpMethod              OutInterpolationMethod                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   bOutRemoveHMDRoll                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMinFacingCameraBlendDistance                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMaxFacingCameraBlendDistance                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       OutCutoutTexture                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubUVBoundingVertexCount               OutBoundingMode                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOpacitySourceMode                      OutOpacitySourceMode                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmitterNormalsMode                     OutEmitterNormalsMode                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutAlphaThreshold                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRequiredPerRendererProps(class UParticleModuleRequired* ParticleModuleRequired, class UMaterialInterface** OutMaterialInterface, EParticleScreenAlignment* OutScreenAlignment, int32* OutSubImages_Horizontal, int32* OutSubImages_Vertical, EParticleSortMode* OutSortMode, EParticleSubUVInterpMethod* OutInterpolationMethod, uint8* bOutRemoveHMDRoll, float* OutMinFacingCameraBlendDistance, float* OutMaxFacingCameraBlendDistance, class UTexture2D** OutCutoutTexture, ESubUVBoundingVertexCount* OutBoundingMode, EOpacitySourceMode* OutOpacitySourceMode, EEmitterNormalsMode* OutEmitterNormalsMode, float* OutAlphaThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRequiredPerRendererProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRequiredPerRendererProps Parms{};

	Parms.ParticleModuleRequired = ParticleModuleRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaterialInterface != nullptr)
		*OutMaterialInterface = Parms.OutMaterialInterface;

	if (OutScreenAlignment != nullptr)
		*OutScreenAlignment = Parms.OutScreenAlignment;

	if (OutSubImages_Horizontal != nullptr)
		*OutSubImages_Horizontal = Parms.OutSubImages_Horizontal;

	if (OutSubImages_Vertical != nullptr)
		*OutSubImages_Vertical = Parms.OutSubImages_Vertical;

	if (OutSortMode != nullptr)
		*OutSortMode = Parms.OutSortMode;

	if (OutInterpolationMethod != nullptr)
		*OutInterpolationMethod = Parms.OutInterpolationMethod;

	if (bOutRemoveHMDRoll != nullptr)
		*bOutRemoveHMDRoll = Parms.bOutRemoveHMDRoll;

	if (OutMinFacingCameraBlendDistance != nullptr)
		*OutMinFacingCameraBlendDistance = Parms.OutMinFacingCameraBlendDistance;

	if (OutMaxFacingCameraBlendDistance != nullptr)
		*OutMaxFacingCameraBlendDistance = Parms.OutMaxFacingCameraBlendDistance;

	if (OutCutoutTexture != nullptr)
		*OutCutoutTexture = Parms.OutCutoutTexture;

	if (OutBoundingMode != nullptr)
		*OutBoundingMode = Parms.OutBoundingMode;

	if (OutOpacitySourceMode != nullptr)
		*OutOpacitySourceMode = Parms.OutOpacitySourceMode;

	if (OutEmitterNormalsMode != nullptr)
		*OutEmitterNormalsMode = Parms.OutEmitterNormalsMode;

	if (OutAlphaThreshold != nullptr)
		*OutAlphaThreshold = Parms.OutAlphaThreshold;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRotationOverLifetimeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleRotationOverLifetime*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRotationOverLife                                    (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutScale                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRotationOverLifetimeProps(class UParticleModuleRotationOverLifetime* ParticleModule, class UDistribution** OutRotationOverLife, bool* bOutScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRotationOverLifetimeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRotationOverLifetimeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRotationOverLife != nullptr)
		*OutRotationOverLife = Parms.OutRotationOverLife;

	if (bOutScale != nullptr)
		*bOutScale = Parms.bOutScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRotationProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleRotation*          ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRotation                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRotationProps(class UParticleModuleRotation* ParticleModule, class UDistribution** OutStartRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRotationProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRotationProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartRotation != nullptr)
		*OutStartRotation = Parms.OutStartRotation;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleRotationRateProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleRotationRate*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartRotationRate                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleRotationRateProps(class UParticleModuleRotationRate* ParticleModule, class UDistribution** OutStartRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleRotationRateProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleRotationRateProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartRotationRate != nullptr)
		*OutStartRotationRate = Parms.OutStartRotationRate;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSizeMultiplyLifeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSizeMultiplyLife*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutLifeMultiplier                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutMultiplyX                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutMultiplyY                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutMultiplyZ                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSizeMultiplyLifeProps(class UParticleModuleSizeMultiplyLife* ParticleModule, class UDistribution** OutLifeMultiplier, bool* OutMultiplyX, bool* OutMultiplyY, bool* OutMultiplyZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSizeMultiplyLifeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSizeMultiplyLifeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLifeMultiplier != nullptr)
		*OutLifeMultiplier = Parms.OutLifeMultiplier;

	if (OutMultiplyX != nullptr)
		*OutMultiplyX = Parms.OutMultiplyX;

	if (OutMultiplyY != nullptr)
		*OutMultiplyY = Parms.OutMultiplyY;

	if (OutMultiplyZ != nullptr)
		*OutMultiplyZ = Parms.OutMultiplyZ;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSizeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSize*              ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartSize                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSizeProps(class UParticleModuleSize* ParticleModule, class UDistribution** OutStartSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSizeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSizeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartSize != nullptr)
		*OutStartSize = Parms.OutStartSize;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSizeScaleBySpeedProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleSizeScaleBySpeed*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutSpeedScale                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutMaxScale                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSizeScaleBySpeedProps(class UParticleModuleSizeScaleBySpeed* ParticleModule, struct FVector2D* OutSpeedScale, struct FVector2D* OutMaxScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSizeScaleBySpeedProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSizeScaleBySpeedProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpeedScale != nullptr)
		*OutSpeedScale = std::move(Parms.OutSpeedScale);

	if (OutMaxScale != nullptr)
		*OutMaxScale = std::move(Parms.OutMaxScale);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSizeScaleProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSizeScale*         ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutSizeScale                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSizeScaleProps(class UParticleModuleSizeScale* ParticleModule, class UDistribution** OutSizeScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSizeScaleProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSizeScaleProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSizeScale != nullptr)
		*OutSizeScale = Parms.OutSizeScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSpawnPerUnitProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSpawnPerUnit*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutUnitScalar                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMovementTolerance                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutSpawnPerUnit                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMaxFrameDistance                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreSpawnRateWhenMoving                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreMovementAlongX                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreMovementAlongY                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreMovementAlongZ                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutProcessSpawnRate                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutProcessBurstList                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSpawnPerUnitProps(class UParticleModuleSpawnPerUnit* ParticleModule, float* OutUnitScalar, float* OutMovementTolerance, class UDistribution** OutSpawnPerUnit, float* OutMaxFrameDistance, bool* bOutIgnoreSpawnRateWhenMoving, bool* bOutIgnoreMovementAlongX, bool* bOutIgnoreMovementAlongY, bool* bOutIgnoreMovementAlongZ, bool* bOutProcessSpawnRate, bool* bOutProcessBurstList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSpawnPerUnitProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSpawnPerUnitProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUnitScalar != nullptr)
		*OutUnitScalar = Parms.OutUnitScalar;

	if (OutMovementTolerance != nullptr)
		*OutMovementTolerance = Parms.OutMovementTolerance;

	if (OutSpawnPerUnit != nullptr)
		*OutSpawnPerUnit = Parms.OutSpawnPerUnit;

	if (OutMaxFrameDistance != nullptr)
		*OutMaxFrameDistance = Parms.OutMaxFrameDistance;

	if (bOutIgnoreSpawnRateWhenMoving != nullptr)
		*bOutIgnoreSpawnRateWhenMoving = Parms.bOutIgnoreSpawnRateWhenMoving;

	if (bOutIgnoreMovementAlongX != nullptr)
		*bOutIgnoreMovementAlongX = Parms.bOutIgnoreMovementAlongX;

	if (bOutIgnoreMovementAlongY != nullptr)
		*bOutIgnoreMovementAlongY = Parms.bOutIgnoreMovementAlongY;

	if (bOutIgnoreMovementAlongZ != nullptr)
		*bOutIgnoreMovementAlongZ = Parms.bOutIgnoreMovementAlongZ;

	if (bOutProcessSpawnRate != nullptr)
		*bOutProcessSpawnRate = Parms.bOutProcessSpawnRate;

	if (bOutProcessBurstList != nullptr)
		*bOutProcessBurstList = Parms.bOutProcessBurstList;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSpawnProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSpawn*             ParticleModuleSpawn                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRate                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRateScale                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleBurstMethod                    OutBurstMethod                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FParticleBurstBlueprint>  OutBurstList                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UDistribution*                    OutBurstScale                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyGlobalSpawnRateScale                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutProcessSpawnRate                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutProcessSpawnBurst                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSpawnProps(class UParticleModuleSpawn* ParticleModuleSpawn, class UDistribution** OutRate, class UDistribution** OutRateScale, EParticleBurstMethod* OutBurstMethod, TArray<struct FParticleBurstBlueprint>* OutBurstList, class UDistribution** OutBurstScale, bool* bOutApplyGlobalSpawnRateScale, bool* bOutProcessSpawnRate, bool* bOutProcessSpawnBurst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSpawnProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSpawnProps Parms{};

	Parms.ParticleModuleSpawn = ParticleModuleSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRate != nullptr)
		*OutRate = Parms.OutRate;

	if (OutRateScale != nullptr)
		*OutRateScale = Parms.OutRateScale;

	if (OutBurstMethod != nullptr)
		*OutBurstMethod = Parms.OutBurstMethod;

	if (OutBurstList != nullptr)
		*OutBurstList = std::move(Parms.OutBurstList);

	if (OutBurstScale != nullptr)
		*OutBurstScale = Parms.OutBurstScale;

	if (bOutApplyGlobalSpawnRateScale != nullptr)
		*bOutApplyGlobalSpawnRateScale = Parms.bOutApplyGlobalSpawnRateScale;

	if (bOutProcessSpawnRate != nullptr)
		*bOutProcessSpawnRate = Parms.bOutProcessSpawnRate;

	if (bOutProcessSpawnBurst != nullptr)
		*bOutProcessSpawnBurst = Parms.bOutProcessSpawnBurst;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSubUVMovieProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSubUVMovie*        ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseEmitterTime                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutFrameRate                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutStartingFrame                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSubUVMovieProps(class UParticleModuleSubUVMovie* ParticleModule, bool* bOutUseEmitterTime, class UDistribution** OutFrameRate, int32* OutStartingFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSubUVMovieProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSubUVMovieProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutUseEmitterTime != nullptr)
		*bOutUseEmitterTime = Parms.bOutUseEmitterTime;

	if (OutFrameRate != nullptr)
		*OutFrameRate = Parms.OutFrameRate;

	if (OutStartingFrame != nullptr)
		*OutStartingFrame = Parms.OutStartingFrame;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleSubUVProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleSubUV*             ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubUVAnimation*                  OutAnimation                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutSubImageIndex                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseRealTime                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleSubUVProps(class UParticleModuleSubUV* ParticleModule, class USubUVAnimation** OutAnimation, class UDistribution** OutSubImageIndex, bool* bOutUseRealTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleSubUVProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleSubUVProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimation != nullptr)
		*OutAnimation = Parms.OutAnimation;

	if (OutSubImageIndex != nullptr)
		*OutSubImageIndex = Parms.OutSubImageIndex;

	if (bOutUseRealTime != nullptr)
		*bOutUseRealTime = Parms.bOutUseRealTime;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleTrailSourceProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleTrailSource*       ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrail2SourceMethod                     OutSourceMethod                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutSourceName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutSourceStrength                                      (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutLockSourceStrength                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSourceOffsetCount                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutSourceOffsetDefaults                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EParticleSourceSelectionMethod          OutSelectionMethod                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInheritRotation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleTrailSourceProps(class UParticleModuleTrailSource* ParticleModule, ETrail2SourceMethod* OutSourceMethod, class FName* OutSourceName, class UDistribution** OutSourceStrength, bool* bOutLockSourceStrength, int32* OutSourceOffsetCount, TArray<struct FVector>* OutSourceOffsetDefaults, EParticleSourceSelectionMethod* OutSelectionMethod, bool* bOutInheritRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleTrailSourceProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleTrailSourceProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSourceMethod != nullptr)
		*OutSourceMethod = Parms.OutSourceMethod;

	if (OutSourceName != nullptr)
		*OutSourceName = Parms.OutSourceName;

	if (OutSourceStrength != nullptr)
		*OutSourceStrength = Parms.OutSourceStrength;

	if (bOutLockSourceStrength != nullptr)
		*bOutLockSourceStrength = Parms.bOutLockSourceStrength;

	if (OutSourceOffsetCount != nullptr)
		*OutSourceOffsetCount = Parms.OutSourceOffsetCount;

	if (OutSourceOffsetDefaults != nullptr)
		*OutSourceOffsetDefaults = std::move(Parms.OutSourceOffsetDefaults);

	if (OutSelectionMethod != nullptr)
		*OutSelectionMethod = Parms.OutSelectionMethod;

	if (bOutInheritRotation != nullptr)
		*bOutInheritRotation = Parms.bOutInheritRotation;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleTypeDataGpuProps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleModuleTypeDataGpu*       ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleTypeDataGpuProps(class UParticleModuleTypeDataGpu* ParticleModule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleTypeDataGpuProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleTypeDataGpuProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleTypeDataMeshProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleTypeDataMesh*      ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      OutMesh                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutLODSizeScale                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseStaticMeshLODs                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutCastShadows                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutDoCollisions                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshScreenAlignment                    OutMeshAlignment                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOverrideMaterial                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOverrideDefaultMotionBlurSettings                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableMotionBlur                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutRollPitchYawRange                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EParticleAxisLock                       OutAxisLockOption                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutCameraFacing                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshCameraFacingUpAxis                 OutCameraFacingUpAxisOption                            (Parm, OutParm, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshCameraFacingOptions                OutCameraFacingOption                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyParticleRotationAsSpin                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutFacingCameraDirectionRatherThanPosition            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutCollisionsConsiderParticleSize                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleTypeDataMeshProps(class UParticleModuleTypeDataMesh* ParticleModule, class UStaticMesh** OutMesh, float* OutLODSizeScale, bool* bOutUseStaticMeshLODs, bool* bOutCastShadows, bool* bOutDoCollisions, EMeshScreenAlignment* OutMeshAlignment, bool* bOutOverrideMaterial, bool* bOutOverrideDefaultMotionBlurSettings, bool* bOutEnableMotionBlur, class UDistribution** OutRollPitchYawRange, EParticleAxisLock* OutAxisLockOption, bool* bOutCameraFacing, EMeshCameraFacingUpAxis* OutCameraFacingUpAxisOption, EMeshCameraFacingOptions* OutCameraFacingOption, bool* bOutApplyParticleRotationAsSpin, bool* bOutFacingCameraDirectionRatherThanPosition, bool* bOutCollisionsConsiderParticleSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleTypeDataMeshProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleTypeDataMeshProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (OutLODSizeScale != nullptr)
		*OutLODSizeScale = Parms.OutLODSizeScale;

	if (bOutUseStaticMeshLODs != nullptr)
		*bOutUseStaticMeshLODs = Parms.bOutUseStaticMeshLODs;

	if (bOutCastShadows != nullptr)
		*bOutCastShadows = Parms.bOutCastShadows;

	if (bOutDoCollisions != nullptr)
		*bOutDoCollisions = Parms.bOutDoCollisions;

	if (OutMeshAlignment != nullptr)
		*OutMeshAlignment = Parms.OutMeshAlignment;

	if (bOutOverrideMaterial != nullptr)
		*bOutOverrideMaterial = Parms.bOutOverrideMaterial;

	if (bOutOverrideDefaultMotionBlurSettings != nullptr)
		*bOutOverrideDefaultMotionBlurSettings = Parms.bOutOverrideDefaultMotionBlurSettings;

	if (bOutEnableMotionBlur != nullptr)
		*bOutEnableMotionBlur = Parms.bOutEnableMotionBlur;

	if (OutRollPitchYawRange != nullptr)
		*OutRollPitchYawRange = Parms.OutRollPitchYawRange;

	if (OutAxisLockOption != nullptr)
		*OutAxisLockOption = Parms.OutAxisLockOption;

	if (bOutCameraFacing != nullptr)
		*bOutCameraFacing = Parms.bOutCameraFacing;

	if (OutCameraFacingUpAxisOption != nullptr)
		*OutCameraFacingUpAxisOption = Parms.OutCameraFacingUpAxisOption;

	if (OutCameraFacingOption != nullptr)
		*OutCameraFacingOption = Parms.OutCameraFacingOption;

	if (bOutApplyParticleRotationAsSpin != nullptr)
		*bOutApplyParticleRotationAsSpin = Parms.bOutApplyParticleRotationAsSpin;

	if (bOutFacingCameraDirectionRatherThanPosition != nullptr)
		*bOutFacingCameraDirectionRatherThanPosition = Parms.bOutFacingCameraDirectionRatherThanPosition;

	if (bOutCollisionsConsiderParticleSize != nullptr)
		*bOutCollisionsConsiderParticleSize = Parms.bOutCollisionsConsiderParticleSize;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleTypeDataRibbonClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UFXConverterUtilitiesLibrary::GetParticleModuleTypeDataRibbonClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleTypeDataRibbonClass");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleTypeDataRibbonClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleTypeDataRibbonProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleTypeDataRibbon*    ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMaxTessellationBetweenParticles                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutSheetsPerTrail                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMaxTrailCount                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMaxParticleInTrailCount                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutDeadTrailsOnDeactivate                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutClipSourceSegment                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnablePreviousTangentRecalculation                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutTangentRecalculationEveryFrame                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutSpawnInitialParticle                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailsRenderAxisOption                 OutRenderAxis                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTangentSpawningScalar                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRenderGeometry                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRenderSpawnPoints                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRenderTangents                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutRenderTessellation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTilingDistance                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutDistanceTessellationStepSize                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableTangentDiffInterpScale                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTangentTessellationScalar                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleTypeDataRibbonProps(class UParticleModuleTypeDataRibbon* ParticleModule, int32* OutMaxTessellationBetweenParticles, int32* OutSheetsPerTrail, int32* OutMaxTrailCount, int32* OutMaxParticleInTrailCount, bool* bOutDeadTrailsOnDeactivate, bool* bOutClipSourceSegment, bool* bOutEnablePreviousTangentRecalculation, bool* bOutTangentRecalculationEveryFrame, bool* bOutSpawnInitialParticle, ETrailsRenderAxisOption* OutRenderAxis, float* OutTangentSpawningScalar, bool* bOutRenderGeometry, bool* bOutRenderSpawnPoints, bool* bOutRenderTangents, bool* bOutRenderTessellation, float* OutTilingDistance, float* OutDistanceTessellationStepSize, bool* bOutEnableTangentDiffInterpScale, float* OutTangentTessellationScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleTypeDataRibbonProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleTypeDataRibbonProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaxTessellationBetweenParticles != nullptr)
		*OutMaxTessellationBetweenParticles = Parms.OutMaxTessellationBetweenParticles;

	if (OutSheetsPerTrail != nullptr)
		*OutSheetsPerTrail = Parms.OutSheetsPerTrail;

	if (OutMaxTrailCount != nullptr)
		*OutMaxTrailCount = Parms.OutMaxTrailCount;

	if (OutMaxParticleInTrailCount != nullptr)
		*OutMaxParticleInTrailCount = Parms.OutMaxParticleInTrailCount;

	if (bOutDeadTrailsOnDeactivate != nullptr)
		*bOutDeadTrailsOnDeactivate = Parms.bOutDeadTrailsOnDeactivate;

	if (bOutClipSourceSegment != nullptr)
		*bOutClipSourceSegment = Parms.bOutClipSourceSegment;

	if (bOutEnablePreviousTangentRecalculation != nullptr)
		*bOutEnablePreviousTangentRecalculation = Parms.bOutEnablePreviousTangentRecalculation;

	if (bOutTangentRecalculationEveryFrame != nullptr)
		*bOutTangentRecalculationEveryFrame = Parms.bOutTangentRecalculationEveryFrame;

	if (bOutSpawnInitialParticle != nullptr)
		*bOutSpawnInitialParticle = Parms.bOutSpawnInitialParticle;

	if (OutRenderAxis != nullptr)
		*OutRenderAxis = Parms.OutRenderAxis;

	if (OutTangentSpawningScalar != nullptr)
		*OutTangentSpawningScalar = Parms.OutTangentSpawningScalar;

	if (bOutRenderGeometry != nullptr)
		*bOutRenderGeometry = Parms.bOutRenderGeometry;

	if (bOutRenderSpawnPoints != nullptr)
		*bOutRenderSpawnPoints = Parms.bOutRenderSpawnPoints;

	if (bOutRenderTangents != nullptr)
		*bOutRenderTangents = Parms.bOutRenderTangents;

	if (bOutRenderTessellation != nullptr)
		*bOutRenderTessellation = Parms.bOutRenderTessellation;

	if (OutTilingDistance != nullptr)
		*OutTilingDistance = Parms.OutTilingDistance;

	if (OutDistanceTessellationStepSize != nullptr)
		*OutDistanceTessellationStepSize = Parms.OutDistanceTessellationStepSize;

	if (bOutEnableTangentDiffInterpScale != nullptr)
		*bOutEnableTangentDiffInterpScale = Parms.bOutEnableTangentDiffInterpScale;

	if (OutTangentTessellationScalar != nullptr)
		*OutTangentTessellationScalar = Parms.OutTangentTessellationScalar;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleVectorFieldLocalProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleVectorFieldLocal*  ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVectorField*                     OutVectorField                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRelativeTranslation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRelativeRotation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutRelativeScale3D                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutIntensity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTightness                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIgnoreComponentTransform                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutTileX                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutTileY                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutTileZ                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutUseFixDT                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleVectorFieldLocalProps(class UParticleModuleVectorFieldLocal* ParticleModule, class UVectorField* OutVectorField, struct FVector* OutRelativeTranslation, struct FRotator* OutRelativeRotation, struct FVector* OutRelativeScale3D, float* OutIntensity, float* OutTightness, bool* bOutIgnoreComponentTransform, bool* bOutTileX, bool* bOutTileY, bool* bOutTileZ, bool* bOutUseFixDT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleVectorFieldLocalProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleVectorFieldLocalProps Parms{};

	Parms.ParticleModule = ParticleModule;
	Parms.OutVectorField = OutVectorField;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRelativeTranslation != nullptr)
		*OutRelativeTranslation = std::move(Parms.OutRelativeTranslation);

	if (OutRelativeRotation != nullptr)
		*OutRelativeRotation = std::move(Parms.OutRelativeRotation);

	if (OutRelativeScale3D != nullptr)
		*OutRelativeScale3D = std::move(Parms.OutRelativeScale3D);

	if (OutIntensity != nullptr)
		*OutIntensity = Parms.OutIntensity;

	if (OutTightness != nullptr)
		*OutTightness = Parms.OutTightness;

	if (bOutIgnoreComponentTransform != nullptr)
		*bOutIgnoreComponentTransform = Parms.bOutIgnoreComponentTransform;

	if (bOutTileX != nullptr)
		*bOutTileX = Parms.bOutTileX;

	if (bOutTileY != nullptr)
		*bOutTileY = Parms.bOutTileY;

	if (bOutTileZ != nullptr)
		*bOutTileZ = Parms.bOutTileZ;

	if (bOutUseFixDT != nullptr)
		*bOutUseFixDT = Parms.bOutUseFixDT;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleVectorFieldRotationRateProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleModuleVectorFieldRotationRate*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRotationRate                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleVectorFieldRotationRateProps(class UParticleModuleVectorFieldRotationRate* ParticleModule, struct FVector* OutRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleVectorFieldRotationRateProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleVectorFieldRotationRateProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRotationRate != nullptr)
		*OutRotationRate = std::move(Parms.OutRotationRate);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleVelocityInheritParentProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleVelocityInheritParent*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutScale                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInWorldSpace                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyOwnerScale                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleVelocityInheritParentProps(class UParticleModuleVelocityInheritParent* ParticleModule, class UDistribution** OutScale, bool* bOutInWorldSpace, bool* bOutApplyOwnerScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleVelocityInheritParentProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleVelocityInheritParentProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScale != nullptr)
		*OutScale = Parms.OutScale;

	if (bOutInWorldSpace != nullptr)
		*bOutInWorldSpace = Parms.bOutInWorldSpace;

	if (bOutApplyOwnerScale != nullptr)
		*bOutApplyOwnerScale = Parms.bOutApplyOwnerScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleVelocityOverLifetimeProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleVelocityOverLifetime*ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutVelOverLife                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutAbsolute                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInWorldSpace                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyOwnerScale                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleVelocityOverLifetimeProps(class UParticleModuleVelocityOverLifetime* ParticleModule, class UDistribution** OutVelOverLife, bool* bOutAbsolute, bool* bOutInWorldSpace, bool* bOutApplyOwnerScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleVelocityOverLifetimeProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleVelocityOverLifetimeProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVelOverLife != nullptr)
		*OutVelOverLife = Parms.OutVelOverLife;

	if (bOutAbsolute != nullptr)
		*bOutAbsolute = Parms.bOutAbsolute;

	if (bOutInWorldSpace != nullptr)
		*bOutInWorldSpace = Parms.bOutInWorldSpace;

	if (bOutApplyOwnerScale != nullptr)
		*bOutApplyOwnerScale = Parms.bOutApplyOwnerScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetParticleModuleVelocityProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleModuleVelocity*          ParticleModule                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartVelocity                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDistribution*                    OutStartVelocityRadial                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutInWorldSpace                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutApplyOwnerScale                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetParticleModuleVelocityProps(class UParticleModuleVelocity* ParticleModule, class UDistribution** OutStartVelocity, class UDistribution** OutStartVelocityRadial, bool* bOutInWorldSpace, bool* bOutApplyOwnerScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetParticleModuleVelocityProps");

	Params::FXConverterUtilitiesLibrary_GetParticleModuleVelocityProps Parms{};

	Parms.ParticleModule = ParticleModule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartVelocity != nullptr)
		*OutStartVelocity = Parms.OutStartVelocity;

	if (OutStartVelocityRadial != nullptr)
		*OutStartVelocityRadial = Parms.OutStartVelocityRadial;

	if (bOutInWorldSpace != nullptr)
		*bOutInWorldSpace = Parms.bOutInWorldSpace;

	if (bOutApplyOwnerScale != nullptr)
		*bOutApplyOwnerScale = Parms.bOutApplyOwnerScale;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetVectorDistributionConstCurveValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionVectorConstantCurve* Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInterpCurveVector               OutInterpCurveVector                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetVectorDistributionConstCurveValues(class UDistributionVectorConstantCurve* Distribution, struct FInterpCurveVector* OutInterpCurveVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetVectorDistributionConstCurveValues");

	Params::FXConverterUtilitiesLibrary_GetVectorDistributionConstCurveValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInterpCurveVector != nullptr)
		*OutInterpCurveVector = std::move(Parms.OutInterpCurveVector);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetVectorDistributionConstValues
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDistributionVectorConstant*      Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutConstVector                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetVectorDistributionConstValues(class UDistributionVectorConstant* Distribution, struct FVector* OutConstVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetVectorDistributionConstValues");

	Params::FXConverterUtilitiesLibrary_GetVectorDistributionConstValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConstVector != nullptr)
		*OutConstVector = std::move(Parms.OutConstVector);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetVectorDistributionParameterValues
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDistributionVectorParameterBase* Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutParameterName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMinInput                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMaxInput                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMinOutput                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMaxOutput                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetVectorDistributionParameterValues(class UDistributionVectorParameterBase* Distribution, class FName* OutParameterName, struct FVector* OutMinInput, struct FVector* OutMaxInput, struct FVector* OutMinOutput, struct FVector* OutMaxOutput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetVectorDistributionParameterValues");

	Params::FXConverterUtilitiesLibrary_GetVectorDistributionParameterValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutParameterName != nullptr)
		*OutParameterName = Parms.OutParameterName;

	if (OutMinInput != nullptr)
		*OutMinInput = std::move(Parms.OutMinInput);

	if (OutMaxInput != nullptr)
		*OutMaxInput = std::move(Parms.OutMaxInput);

	if (OutMinOutput != nullptr)
		*OutMinOutput = std::move(Parms.OutMinOutput);

	if (OutMaxOutput != nullptr)
		*OutMaxOutput = std::move(Parms.OutMaxOutput);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetVectorDistributionUniformCurveValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDistributionVectorUniformCurve*  Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInterpCurveTwoVectors           OutInterpCurveTwoVectors                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetVectorDistributionUniformCurveValues(class UDistributionVectorUniformCurve* Distribution, struct FInterpCurveTwoVectors* OutInterpCurveTwoVectors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetVectorDistributionUniformCurveValues");

	Params::FXConverterUtilitiesLibrary_GetVectorDistributionUniformCurveValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInterpCurveTwoVectors != nullptr)
		*OutInterpCurveTwoVectors = std::move(Parms.OutInterpCurveTwoVectors);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.GetVectorDistributionUniformValues
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDistributionVectorUniform*       Distribution                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutMax                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::GetVectorDistributionUniformValues(class UDistributionVectorUniform* Distribution, struct FVector* OutMin, struct FVector* OutMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "GetVectorDistributionUniformValues");

	Params::FXConverterUtilitiesLibrary_GetVectorDistributionUniformValues Parms{};

	Parms.Distribution = Distribution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMin != nullptr)
		*OutMin = std::move(Parms.OutMin);

	if (OutMax != nullptr)
		*OutMax = std::move(Parms.OutMax);
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.KeysFromInterpCurveFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInterpCurveFloat                Curve                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRichCurveKeyBP> UFXConverterUtilitiesLibrary::KeysFromInterpCurveFloat(const struct FInterpCurveFloat& Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "KeysFromInterpCurveFloat");

	Params::FXConverterUtilitiesLibrary_KeysFromInterpCurveFloat Parms{};

	Parms.Curve = std::move(Curve);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.KeysFromInterpCurveTwoVectors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInterpCurveTwoVectors           Curve                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ComponentIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRichCurveKeyBP> UFXConverterUtilitiesLibrary::KeysFromInterpCurveTwoVectors(const struct FInterpCurveTwoVectors& Curve, int32 ComponentIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "KeysFromInterpCurveTwoVectors");

	Params::FXConverterUtilitiesLibrary_KeysFromInterpCurveTwoVectors Parms{};

	Parms.Curve = std::move(Curve);
	Parms.ComponentIdx = ComponentIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.KeysFromInterpCurveVector
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInterpCurveVector               Curve                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ComponentIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRichCurveKeyBP> UFXConverterUtilitiesLibrary::KeysFromInterpCurveVector(const struct FInterpCurveVector& Curve, int32 ComponentIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "KeysFromInterpCurveVector");

	Params::FXConverterUtilitiesLibrary_KeysFromInterpCurveVector Parms{};

	Parms.Curve = std::move(Curve);
	Parms.ComponentIdx = ComponentIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.KeysFromInterpCurveVector2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInterpCurveVector2D             Curve                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ComponentIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKeyBP>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FRichCurveKeyBP> UFXConverterUtilitiesLibrary::KeysFromInterpCurveVector2D(const struct FInterpCurveVector2D& Curve, int32 ComponentIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "KeysFromInterpCurveVector2D");

	Params::FXConverterUtilitiesLibrary_KeysFromInterpCurveVector2D Parms{};

	Parms.Curve = std::move(Curve);
	Parms.ComponentIdx = ComponentIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CascadeToNiagaraConverter.FXConverterUtilitiesLibrary.SetMeshRendererMaterialOverridesFromCascade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNiagaraMeshRendererProperties*   MeshRendererProps                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInterface*>       MeshMaterials                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFXConverterUtilitiesLibrary::SetMeshRendererMaterialOverridesFromCascade(class UNiagaraMeshRendererProperties* MeshRendererProps, const TArray<class UMaterialInterface*>& MeshMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FXConverterUtilitiesLibrary", "SetMeshRendererMaterialOverridesFromCascade");

	Params::FXConverterUtilitiesLibrary_SetMeshRendererMaterialOverridesFromCascade Parms{};

	Parms.MeshRendererProps = MeshRendererProps;
	Parms.MeshMaterials = std::move(MeshMaterials);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CascadeToNiagaraConverter.ConvertCascadeToNiagaraResults.Init
// (Final, Native, Public)

void UConvertCascadeToNiagaraResults::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConvertCascadeToNiagaraResults", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

