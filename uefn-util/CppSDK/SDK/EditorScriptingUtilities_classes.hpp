#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EditorScriptingUtilities

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "EditorScriptingUtilities_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "StaticMeshEditor_structs.hpp"


namespace SDK
{

// Class EditorScriptingUtilities.EditorAssetLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorAssetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckoutAsset(const class FString& AssetToCheckout);
	static bool CheckoutDirectory(const class FString& DirectoryPath, bool bRecursive);
	static bool CheckoutLoadedAsset(class UObject* AssetToCheckout);
	static bool CheckoutLoadedAssets(const TArray<class UObject*>& AssetsToCheckout);
	static bool ConsolidateAssets(class UObject* AssetToConsolidateTo, const TArray<class UObject*>& AssetsToConsolidate);
	static bool DeleteAsset(const class FString& AssetPathToDelete);
	static bool DeleteDirectory(const class FString& DirectoryPath);
	static bool DeleteLoadedAsset(class UObject* AssetToDelete);
	static bool DeleteLoadedAssets(const TArray<class UObject*>& AssetsToDelete);
	static bool DoAssetsExist(const TArray<class FString>& AssetPaths);
	static bool DoesAssetExist(const class FString& AssetPath);
	static bool DoesDirectoryExist(const class FString& DirectoryPath);
	static bool DoesDirectoryHaveAssets(const class FString& DirectoryPath, bool bRecursive);
	static class UObject* DuplicateAsset(const class FString& SourceAssetPath, const class FString& DestinationAssetPath);
	static bool DuplicateDirectory(const class FString& SourceDirectoryPath, const class FString& DestinationDirectoryPath);
	static class UObject* DuplicateLoadedAsset(class UObject* SourceAsset, const class FString& DestinationAssetPath);
	static struct FAssetData FindAssetData(const class FString& AssetPath);
	static TArray<class FString> FindPackageReferencersForAsset(const class FString& AssetPath, bool bLoadAssetsToConfirm);
	static class FString GetMetadataTag(class UObject* Object, class FName Tag);
	static TMap<class FName, class FString> GetMetadataTagValues(class UObject* Object);
	static class UPackage* GetPackageForObject(class UObject* Object);
	static class FString GetPathNameForLoadedAsset(class UObject* LoadedAsset);
	static class FString GetProjectRootAssetDirectory();
	static TMap<class FName, class FString> GetTagValues(const class FString& AssetPath);
	static TArray<class FString> ListAssetByTagValue(class FName TagName, const class FString& TagValue);
	static TArray<class FString> ListAssets(const class FString& DirectoryPath, bool bRecursive, bool bIncludeFolder);
	static class UObject* LoadAsset(const class FString& AssetPath);
	static class UClass* LoadBlueprintClass(const class FString& AssetPath);
	static bool MakeDirectory(const class FString& DirectoryPath);
	static void RemoveMetadataTag(class UObject* Object, class FName Tag);
	static bool RenameAsset(const class FString& SourceAssetPath, const class FString& DestinationAssetPath);
	static bool RenameDirectory(const class FString& SourceDirectoryPath, const class FString& DestinationDirectoryPath);
	static bool RenameLoadedAsset(class UObject* SourceAsset, const class FString& DestinationAssetPath);
	static bool SaveAsset(const class FString& AssetToSave, bool bOnlyIfIsDirty);
	static bool SaveDirectory(const class FString& DirectoryPath, bool bOnlyIfIsDirty, bool bRecursive);
	static bool SaveLoadedAsset(class UObject* AssetToSave, bool bOnlyIfIsDirty);
	static bool SaveLoadedAssets(const TArray<class UObject*>& AssetsToSave, bool bOnlyIfIsDirty);
	static void SetMetadataTag(class UObject* Object, class FName Tag, const class FString& Value);
	static void SyncBrowserToObjects(const TArray<class FString>& AssetPaths);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorAssetLibrary">();
	}
	static class UEditorAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorAssetLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorDialogLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorDialogLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EAppReturnType ShowMessage(const class FText& Title, const class FText& Message, EAppMsgType MessageType, EAppReturnType DefaultValue, EAppMsgCategory MessageCategory);
	static bool ShowObjectDetailsView(const class FText& Title, class UObject* InOutObject, const struct FEditorDialogLibraryObjectDetailsViewOptions& Options);
	static bool ShowObjectsDetailsView(const class FText& Title, const TArray<class UObject*>& InOutObjects, const struct FEditorDialogLibraryObjectDetailsViewOptions& Options);
	static bool ShowSuppressableWarningDialog(const class FText& Title, const class FText& Message, const class FString& InIniSettingName, const class FString& InIniSettingFileNameOverride, bool bDefaultValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorDialogLibrary">();
	}
	static class UEditorDialogLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorDialogLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorFilterLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorFilterLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> ByActorLabel(const TArray<class AActor*>& TargetArray, const class FString& NameSubString, EEditorScriptingStringMatchType StringMatch, EEditorScriptingFilterType FilterType, bool bIgnoreCase);
	static TArray<class AActor*> ByActorTag(const TArray<class AActor*>& TargetArray, class FName Tag, EEditorScriptingFilterType FilterType);
	static TArray<class UObject*> ByClass(const TArray<class UObject*>& TargetArray, TSubclassOf<class UObject> ObjectClass, EEditorScriptingFilterType FilterType);
	static TArray<class UObject*> ByIDName(const TArray<class UObject*>& TargetArray, const class FString& NameSubString, EEditorScriptingStringMatchType StringMatch, EEditorScriptingFilterType FilterType);
	static TArray<class AActor*> ByLayer(const TArray<class AActor*>& TargetArray, class FName LayerName, EEditorScriptingFilterType FilterType);
	static TArray<class AActor*> ByLevelName(const TArray<class AActor*>& TargetArray, class FName LevelName, EEditorScriptingFilterType FilterType);
	static TArray<class AActor*> BySelection(const TArray<class AActor*>& TargetArray, EEditorScriptingFilterType FilterType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorFilterLibrary">();
	}
	static class UEditorFilterLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorFilterLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorLevelLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorLevelLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearActorSelectionSet();
	static TArray<class AActor*> ConvertActors(const TArray<class AActor*>& Actors, TSubclassOf<class AActor> ActorClass, const class FString& StaticMeshPackagePath);
	static bool CreateProxyMeshActor(const TArray<class AStaticMeshActor*>& ActorsToMerge, const struct FCreateProxyMeshActorOptions& MergeOptions, class AStaticMeshActor** OutMergedActor);
	static bool DestroyActor(class AActor* ActorToDestroy);
	static void EditorEndPlay();
	static void EditorInvalidateViewports();
	static void EditorPlaySimulate();
	static void EditorSetGameView(bool bGameView);
	static void EjectPilotLevelActor();
	static class AActor* GetActorReference(const class FString& PathToActor);
	static TArray<class AActor*> GetAllLevelActors();
	static TArray<class UActorComponent*> GetAllLevelActorsComponents();
	static class UWorld* GetEditorWorld();
	static class UWorld* GetGameWorld();
	static bool GetLevelViewportCameraInfo(struct FVector* CameraLocation, struct FRotator* CameraRotation);
	static TArray<class UWorld*> GetPIEWorlds(bool bIncludeDedicatedServer);
	static TArray<class AActor*> GetSelectedLevelActors();
	static class AActor* JoinStaticMeshActors(const TArray<class AStaticMeshActor*>& ActorsToJoin, const struct FJoinStaticMeshActorsOptions& JoinOptions);
	static bool LoadLevel(const class FString& AssetPath);
	static bool MergeStaticMeshActors(const TArray<class AStaticMeshActor*>& ActorsToMerge, const struct FMergeStaticMeshActorsOptions& MergeOptions, class AStaticMeshActor** OutMergedActor);
	static bool NewLevel(const class FString& AssetPath);
	static bool NewLevelFromTemplate(const class FString& AssetPath, const class FString& TemplateAssetPath);
	static void PilotLevelActor(class AActor* ActorToPilot);
	static void ReplaceMeshComponentsMaterials(const TArray<class UMeshComponent*>& MeshComponents, class UMaterialInterface* MaterialToBeReplaced, class UMaterialInterface* NewMaterial);
	static void ReplaceMeshComponentsMaterialsOnActors(const TArray<class AActor*>& Actors, class UMaterialInterface* MaterialToBeReplaced, class UMaterialInterface* NewMaterial);
	static void ReplaceMeshComponentsMeshes(const TArray<class UStaticMeshComponent*>& MeshComponents, class UStaticMesh* MeshToBeReplaced, class UStaticMesh* NewMesh);
	static void ReplaceMeshComponentsMeshesOnActors(const TArray<class AActor*>& Actors, class UStaticMesh* MeshToBeReplaced, class UStaticMesh* NewMesh);
	static void ReplaceSelectedActors(const class FString& InAssetPath);
	static bool SaveAllDirtyLevels();
	static bool SaveCurrentLevel();
	static void SelectNothing();
	static void SetActorSelectionState(class AActor* Actor, bool bShouldBeSelected);
	static bool SetCurrentLevelByName(class FName LevelName);
	static void SetLevelViewportCameraInfo(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	static void SetSelectedLevelActors(const TArray<class AActor*>& ActorsToSelect);
	static class AActor* SpawnActorFromClass(TSubclassOf<class AActor> ActorClass, const struct FVector& Location, const struct FRotator& Rotation, bool bTransient);
	static class AActor* SpawnActorFromObject(class UObject* ObjectToUse, const struct FVector& Location, const struct FRotator& Rotation, bool bTransient);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorLevelLibrary">();
	}
	static class UEditorLevelLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorLevelLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorPythonScriptingLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorPythonScriptingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetKeepPythonScriptAlive();
	static void SetKeepPythonScriptAlive(const bool bNewKeepAlive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorPythonScriptingLibrary">();
	}
	static class UEditorPythonScriptingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorPythonScriptingLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorSkeletalMeshLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorSkeletalMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UPhysicsAsset* CreatePhysicsAsset(class USkeletalMesh* SkeletalMesh);
	static void GetLodBuildSettings(const class USkeletalMesh* SkeletalMesh, const int32 LodIndex, struct FSkeletalMeshBuildSettings* OutBuildOptions);
	static int32 GetLODCount(class USkeletalMesh* SkeletalMesh);
	static int32 GetNumVerts(class USkeletalMesh* SkeletalMesh, int32 LODIndex);
	static int32 ImportLOD(class USkeletalMesh* BaseMesh, const int32 LODIndex, const class FString& SourceFilename);
	static bool RegenerateLOD(class USkeletalMesh* SkeletalMesh, int32 NewLODCount, bool bRegenerateEvenIfImported, bool bGenerateBaseLOD);
	static bool ReimportAllCustomLODs(class USkeletalMesh* SkeletalMesh);
	static bool RemoveLODs(class USkeletalMesh* SkeletalMesh, const TArray<int32>& ToRemoveLODs);
	static bool RenameSocket(class USkeletalMesh* SkeletalMesh, class FName OldName, class FName NewName);
	static void SetLodBuildSettings(class USkeletalMesh* SkeletalMesh, const int32 LodIndex, const struct FSkeletalMeshBuildSettings& BuildOptions);
	static bool StripLODGeometry(class USkeletalMesh* SkeletalMesh, const int32 LODIndex, class UTexture2D* TextureMask, const float Threshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorSkeletalMeshLibrary">();
	}
	static class UEditorSkeletalMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorSkeletalMeshLibrary>();
	}
};

// Class EditorScriptingUtilities.EditorStaticMeshLibrary
// 0x0000 (0x0030 - 0x0030)
class UEditorStaticMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddSimpleCollisions(class UStaticMesh* StaticMesh, const EScriptCollisionShapeType ShapeType);
	static int32 AddSimpleCollisionsWithNotification(class UStaticMesh* StaticMesh, const EScriptCollisionShapeType ShapeType, bool bApplyChanges);
	static bool AddUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex);
	static bool BulkSetConvexDecompositionCollisions(const TArray<class UStaticMesh*>& StaticMeshes, int32 HullCount, int32 MaxHullVerts, int32 HullPrecision);
	static bool BulkSetConvexDecompositionCollisionsWithNotification(const TArray<class UStaticMesh*>& StaticMeshes, int32 HullCount, int32 MaxHullVerts, int32 HullPrecision, bool bApplyChanges);
	static void EnableSectionCastShadow(class UStaticMesh* StaticMesh, bool bCastShadow, int32 LODIndex, int32 SectionIndex);
	static void EnableSectionCollision(class UStaticMesh* StaticMesh, bool bCollisionEnabled, int32 LODIndex, int32 SectionIndex);
	static bool GenerateBoxUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex, int32 UVChannelIndex, const struct FVector& Position, const struct FRotator& Orientation, const struct FVector& Size);
	static bool GenerateCylindricalUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex, int32 UVChannelIndex, const struct FVector& Position, const struct FRotator& Orientation, const struct FVector2D& Tiling);
	static bool GeneratePlanarUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex, int32 UVChannelIndex, const struct FVector& Position, const struct FRotator& Orientation, const struct FVector2D& Tiling);
	static ECollisionTraceFlag GetCollisionComplexity(class UStaticMesh* StaticMesh);
	static int32 GetConvexCollisionCount(class UStaticMesh* StaticMesh);
	static void GetLodBuildSettings(const class UStaticMesh* StaticMesh, const int32 LodIndex, struct FMeshBuildSettings* OutBuildOptions);
	static int32 GetLodCount(class UStaticMesh* StaticMesh);
	static void GetLodReductionSettings(const class UStaticMesh* StaticMesh, const int32 LodIndex, struct FMeshReductionSettings* OutReductionOptions);
	static TArray<float> GetLodScreenSizes(class UStaticMesh* StaticMesh);
	static int32 GetNumberMaterials(class UStaticMesh* StaticMesh);
	static int32 GetNumberVerts(class UStaticMesh* StaticMesh, int32 LODIndex);
	static int32 GetNumUVChannels(class UStaticMesh* StaticMesh, int32 LODIndex);
	static int32 GetSimpleCollisionCount(class UStaticMesh* StaticMesh);
	static bool HasInstanceVertexColors(class UStaticMeshComponent* StaticMeshComponent);
	static bool HasVertexColors(class UStaticMesh* StaticMesh);
	static int32 ImportLOD(class UStaticMesh* BaseStaticMesh, const int32 LODIndex, const class FString& SourceFilename);
	static bool InsertUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex, int32 UVChannelIndex);
	static bool IsSectionCollisionEnabled(class UStaticMesh* StaticMesh, int32 LODIndex, int32 SectionIndex);
	static bool ReimportAllCustomLODs(class UStaticMesh* StaticMesh);
	static bool RemoveCollisions(class UStaticMesh* StaticMesh);
	static bool RemoveCollisionsWithNotification(class UStaticMesh* StaticMesh, bool bApplyChanges);
	static bool RemoveLods(class UStaticMesh* StaticMesh);
	static bool RemoveUVChannel(class UStaticMesh* StaticMesh, int32 LODIndex, int32 UVChannelIndex);
	static void SetAllowCPUAccess(class UStaticMesh* StaticMesh, bool bAllowCPUAccess);
	static bool SetConvexDecompositionCollisions(class UStaticMesh* StaticMesh, int32 HullCount, int32 MaxHullVerts, int32 HullPrecision);
	static bool SetConvexDecompositionCollisionsWithNotification(class UStaticMesh* StaticMesh, int32 HullCount, int32 MaxHullVerts, int32 HullPrecision, bool bApplyChanges);
	static bool SetGenerateLightmapUVs(class UStaticMesh* StaticMesh, bool bGenerateLightmapUVs);
	static void SetLodBuildSettings(class UStaticMesh* StaticMesh, const int32 LodIndex, const struct FMeshBuildSettings& BuildOptions);
	static int32 SetLodFromStaticMesh(class UStaticMesh* DestinationStaticMesh, int32 DestinationLodIndex, class UStaticMesh* SourceStaticMesh, int32 SourceLodIndex, bool bReuseExistingMaterialSlots);
	static void SetLodReductionSettings(class UStaticMesh* StaticMesh, const int32 LodIndex, const struct FMeshReductionSettings& ReductionOptions);
	static int32 SetLods(class UStaticMesh* StaticMesh, const struct FStaticMeshReductionOptions& ReductionOptions);
	static int32 SetLodsWithNotification(class UStaticMesh* StaticMesh, const struct FStaticMeshReductionOptions& ReductionOptions, bool bApplyChanges);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorStaticMeshLibrary">();
	}
	static class UEditorStaticMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorStaticMeshLibrary>();
	}
};

}

